// Copyright 1998-2016 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Boilerplate C++ definitions for a single module.
	This is automatically generated by UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "Private/LeapMotionPrivatePCH.h"
#include "GeneratedCppIncludes.h"
#include "LeapMotion.generated.dep.h"
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCode1LeapMotion() {}
FName LEAPMOTION_CircleGestureDetected = FName(TEXT("CircleGestureDetected"));
FName LEAPMOTION_FingerCountChanged = FName(TEXT("FingerCountChanged"));
FName LEAPMOTION_GestureDetected = FName(TEXT("GestureDetected"));
FName LEAPMOTION_HandCountChanged = FName(TEXT("HandCountChanged"));
FName LEAPMOTION_KeyTapGestureDetected = FName(TEXT("KeyTapGestureDetected"));
FName LEAPMOTION_LeapFingerMoved = FName(TEXT("LeapFingerMoved"));
FName LEAPMOTION_LeapFrontFingerTouch = FName(TEXT("LeapFrontFingerTouch"));
FName LEAPMOTION_LeapFrontMostFingerMoved = FName(TEXT("LeapFrontMostFingerMoved"));
FName LEAPMOTION_LeapHandGrabbed = FName(TEXT("LeapHandGrabbed"));
FName LEAPMOTION_LeapHandGrabbing = FName(TEXT("LeapHandGrabbing"));
FName LEAPMOTION_LeapHandMoved = FName(TEXT("LeapHandMoved"));
FName LEAPMOTION_LeapHandPinched = FName(TEXT("LeapHandPinched"));
FName LEAPMOTION_LeapHandPinching = FName(TEXT("LeapHandPinching"));
FName LEAPMOTION_LeapHandReleased = FName(TEXT("LeapHandReleased"));
FName LEAPMOTION_LeapHandUnpinched = FName(TEXT("LeapHandUnpinched"));
FName LEAPMOTION_LeapLeftHandMoved = FName(TEXT("LeapLeftHandMoved"));
FName LEAPMOTION_LeapLeftMostFingerMoved = FName(TEXT("LeapLeftMostFingerMoved"));
FName LEAPMOTION_LeapRightHandMoved = FName(TEXT("LeapRightHandMoved"));
FName LEAPMOTION_LeapRightMostFingerMoved = FName(TEXT("LeapRightMostFingerMoved"));
FName LEAPMOTION_RawImageReceived = FName(TEXT("RawImageReceived"));
FName LEAPMOTION_ScreenTapGestureDetected = FName(TEXT("ScreenTapGestureDetected"));
FName LEAPMOTION_SwipeGestureDetected = FName(TEXT("SwipeGestureDetected"));
	void UAnimBone::StaticRegisterNativesUAnimBone()
	{
		FNativeFunctionRegistrar::RegisterFunction(UAnimBone::StaticClass(), "ChangeBasis",(Native)&UAnimBone::execChangeBasis);
		FNativeFunctionRegistrar::RegisterFunction(UAnimBone::StaticClass(), "Enabled",(Native)&UAnimBone::execEnabled);
		FNativeFunctionRegistrar::RegisterFunction(UAnimBone::StaticClass(), "GetTransform",(Native)&UAnimBone::execGetTransform);
		FNativeFunctionRegistrar::RegisterFunction(UAnimBone::StaticClass(), "SetEnabled",(Native)&UAnimBone::execSetEnabled);
		FNativeFunctionRegistrar::RegisterFunction(UAnimBone::StaticClass(), "SetFromTransform",(Native)&UAnimBone::execSetFromTransform);
		FNativeFunctionRegistrar::RegisterFunction(UAnimBone::StaticClass(), "TranslateBone",(Native)&UAnimBone::execTranslateBone);
	}
	IMPLEMENT_CLASS(UAnimBone, 3717051629);
static class UEnum* LeapZone_StaticEnum()
{
	extern LEAPMOTION_API class UPackage* Z_Construct_UPackage__Script_LeapMotion();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern LEAPMOTION_API class UEnum* Z_Construct_UEnum_LeapMotion_LeapZone();
		Singleton = GetStaticEnum(Z_Construct_UEnum_LeapMotion_LeapZone, Z_Construct_UPackage__Script_LeapMotion(), TEXT("LeapZone"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_LeapZone(LeapZone_StaticEnum, TEXT("/Script/LeapMotion"), TEXT("LeapZone"), false, nullptr, nullptr);
static class UEnum* LeapHandType_StaticEnum()
{
	extern LEAPMOTION_API class UPackage* Z_Construct_UPackage__Script_LeapMotion();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern LEAPMOTION_API class UEnum* Z_Construct_UEnum_LeapMotion_LeapHandType();
		Singleton = GetStaticEnum(Z_Construct_UEnum_LeapMotion_LeapHandType, Z_Construct_UPackage__Script_LeapMotion(), TEXT("LeapHandType"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_LeapHandType(LeapHandType_StaticEnum, TEXT("/Script/LeapMotion"), TEXT("LeapHandType"), false, nullptr, nullptr);
static class UEnum* LeapBasicDirection_StaticEnum()
{
	extern LEAPMOTION_API class UPackage* Z_Construct_UPackage__Script_LeapMotion();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern LEAPMOTION_API class UEnum* Z_Construct_UEnum_LeapMotion_LeapBasicDirection();
		Singleton = GetStaticEnum(Z_Construct_UEnum_LeapMotion_LeapBasicDirection, Z_Construct_UPackage__Script_LeapMotion(), TEXT("LeapBasicDirection"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_LeapBasicDirection(LeapBasicDirection_StaticEnum, TEXT("/Script/LeapMotion"), TEXT("LeapBasicDirection"), false, nullptr, nullptr);
static class UEnum* LeapGestureState_StaticEnum()
{
	extern LEAPMOTION_API class UPackage* Z_Construct_UPackage__Script_LeapMotion();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern LEAPMOTION_API class UEnum* Z_Construct_UEnum_LeapMotion_LeapGestureState();
		Singleton = GetStaticEnum(Z_Construct_UEnum_LeapMotion_LeapGestureState, Z_Construct_UPackage__Script_LeapMotion(), TEXT("LeapGestureState"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_LeapGestureState(LeapGestureState_StaticEnum, TEXT("/Script/LeapMotion"), TEXT("LeapGestureState"), false, nullptr, nullptr);
static class UEnum* LeapGestureType_StaticEnum()
{
	extern LEAPMOTION_API class UPackage* Z_Construct_UPackage__Script_LeapMotion();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern LEAPMOTION_API class UEnum* Z_Construct_UEnum_LeapMotion_LeapGestureType();
		Singleton = GetStaticEnum(Z_Construct_UEnum_LeapMotion_LeapGestureType, Z_Construct_UPackage__Script_LeapMotion(), TEXT("LeapGestureType"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_LeapGestureType(LeapGestureType_StaticEnum, TEXT("/Script/LeapMotion"), TEXT("LeapGestureType"), false, nullptr, nullptr);
static class UEnum* LeapBoneType_StaticEnum()
{
	extern LEAPMOTION_API class UPackage* Z_Construct_UPackage__Script_LeapMotion();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern LEAPMOTION_API class UEnum* Z_Construct_UEnum_LeapMotion_LeapBoneType();
		Singleton = GetStaticEnum(Z_Construct_UEnum_LeapMotion_LeapBoneType, Z_Construct_UPackage__Script_LeapMotion(), TEXT("LeapBoneType"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_LeapBoneType(LeapBoneType_StaticEnum, TEXT("/Script/LeapMotion"), TEXT("LeapBoneType"), false, nullptr, nullptr);
static class UEnum* LeapFingerType_StaticEnum()
{
	extern LEAPMOTION_API class UPackage* Z_Construct_UPackage__Script_LeapMotion();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern LEAPMOTION_API class UEnum* Z_Construct_UEnum_LeapMotion_LeapFingerType();
		Singleton = GetStaticEnum(Z_Construct_UEnum_LeapMotion_LeapFingerType, Z_Construct_UPackage__Script_LeapMotion(), TEXT("LeapFingerType"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_LeapFingerType(LeapFingerType_StaticEnum, TEXT("/Script/LeapMotion"), TEXT("LeapFingerType"), false, nullptr, nullptr);
static class UEnum* AnimHandType_StaticEnum()
{
	extern LEAPMOTION_API class UPackage* Z_Construct_UPackage__Script_LeapMotion();
	static class UEnum* Singleton = NULL;
	if (!Singleton)
	{
		extern LEAPMOTION_API class UEnum* Z_Construct_UEnum_LeapMotion_AnimHandType();
		Singleton = GetStaticEnum(Z_Construct_UEnum_LeapMotion_AnimHandType, Z_Construct_UPackage__Script_LeapMotion(), TEXT("AnimHandType"));
	}
	return Singleton;
}
static FCompiledInDeferEnum Z_CompiledInDeferEnum_UEnum_AnimHandType(AnimHandType_StaticEnum, TEXT("/Script/LeapMotion"), TEXT("AnimHandType"), false, nullptr, nullptr);
	void UAnimFinger::StaticRegisterNativesUAnimFinger()
	{
		FNativeFunctionRegistrar::RegisterFunction(UAnimFinger::StaticClass(), "ChangeBasis",(Native)&UAnimFinger::execChangeBasis);
		FNativeFunctionRegistrar::RegisterFunction(UAnimFinger::StaticClass(), "Enabled",(Native)&UAnimFinger::execEnabled);
		FNativeFunctionRegistrar::RegisterFunction(UAnimFinger::StaticClass(), "SetEnabled",(Native)&UAnimFinger::execSetEnabled);
		FNativeFunctionRegistrar::RegisterFunction(UAnimFinger::StaticClass(), "SetFromLeapFinger",(Native)&UAnimFinger::execSetFromLeapFinger);
		FNativeFunctionRegistrar::RegisterFunction(UAnimFinger::StaticClass(), "TranslateFinger",(Native)&UAnimFinger::execTranslateFinger);
	}
	IMPLEMENT_CLASS(UAnimFinger, 923695845);
	void ULeapHand::StaticRegisterNativesULeapHand()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapHand::StaticClass(), "Fingers",(Native)&ULeapHand::execFingers);
		FNativeFunctionRegistrar::RegisterFunction(ULeapHand::StaticClass(), "Frame",(Native)&ULeapHand::execFrame);
		FNativeFunctionRegistrar::RegisterFunction(ULeapHand::StaticClass(), "RotationAngle",(Native)&ULeapHand::execRotationAngle);
		FNativeFunctionRegistrar::RegisterFunction(ULeapHand::StaticClass(), "RotationAngleWithAxis",(Native)&ULeapHand::execRotationAngleWithAxis);
		FNativeFunctionRegistrar::RegisterFunction(ULeapHand::StaticClass(), "RotationAxis",(Native)&ULeapHand::execRotationAxis);
		FNativeFunctionRegistrar::RegisterFunction(ULeapHand::StaticClass(), "RotationMatrix",(Native)&ULeapHand::execRotationMatrix);
		FNativeFunctionRegistrar::RegisterFunction(ULeapHand::StaticClass(), "RotationProbability",(Native)&ULeapHand::execRotationProbability);
		FNativeFunctionRegistrar::RegisterFunction(ULeapHand::StaticClass(), "ScaleFactor",(Native)&ULeapHand::execScaleFactor);
		FNativeFunctionRegistrar::RegisterFunction(ULeapHand::StaticClass(), "ScaleProbability",(Native)&ULeapHand::execScaleProbability);
		FNativeFunctionRegistrar::RegisterFunction(ULeapHand::StaticClass(), "Translation",(Native)&ULeapHand::execTranslation);
		FNativeFunctionRegistrar::RegisterFunction(ULeapHand::StaticClass(), "TranslationProbability",(Native)&ULeapHand::execTranslationProbability);
	}
	IMPLEMENT_CLASS(ULeapHand, 3019799655);
	void UAnimHand::StaticRegisterNativesUAnimHand()
	{
		FNativeFunctionRegistrar::RegisterFunction(UAnimHand::StaticClass(), "ChangeBasis",(Native)&UAnimHand::execChangeBasis);
		FNativeFunctionRegistrar::RegisterFunction(UAnimHand::StaticClass(), "Enabled",(Native)&UAnimHand::execEnabled);
		FNativeFunctionRegistrar::RegisterFunction(UAnimHand::StaticClass(), "SetEnabled",(Native)&UAnimHand::execSetEnabled);
		FNativeFunctionRegistrar::RegisterFunction(UAnimHand::StaticClass(), "SetFromLeapHand",(Native)&UAnimHand::execSetFromLeapHand);
		FNativeFunctionRegistrar::RegisterFunction(UAnimHand::StaticClass(), "TranslateHand",(Native)&UAnimHand::execTranslateHand);
	}
	IMPLEMENT_CLASS(UAnimHand, 3075510319);
	void UAnimBody::StaticRegisterNativesUAnimBody()
	{
		FNativeFunctionRegistrar::RegisterFunction(UAnimBody::StaticClass(), "ChangeBasis",(Native)&UAnimBody::execChangeBasis);
		FNativeFunctionRegistrar::RegisterFunction(UAnimBody::StaticClass(), "Enabled",(Native)&UAnimBody::execEnabled);
		FNativeFunctionRegistrar::RegisterFunction(UAnimBody::StaticClass(), "SetEnabled",(Native)&UAnimBody::execSetEnabled);
		FNativeFunctionRegistrar::RegisterFunction(UAnimBody::StaticClass(), "TranslateBody",(Native)&UAnimBody::execTranslateBody);
	}
	IMPLEMENT_CLASS(UAnimBody, 2856039577);
	void ULeapArm::StaticRegisterNativesULeapArm()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapArm::StaticClass(), "GetOrientation",(Native)&ULeapArm::execGetOrientation);
	}
	IMPLEMENT_CLASS(ULeapArm, 215738858);
	void ULeapBaseObject::StaticRegisterNativesULeapBaseObject()
	{
	}
	IMPLEMENT_CLASS(ULeapBaseObject, 2294068931);
	void ULeapBone::StaticRegisterNativesULeapBone()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapBone::StaticClass(), "Different",(Native)&ULeapBone::execDifferent);
		FNativeFunctionRegistrar::RegisterFunction(ULeapBone::StaticClass(), "Equal",(Native)&ULeapBone::execEqual);
		FNativeFunctionRegistrar::RegisterFunction(ULeapBone::StaticClass(), "GetOrientation",(Native)&ULeapBone::execGetOrientation);
	}
	IMPLEMENT_CLASS(ULeapBone, 963172110);
	void ULeapGesture::StaticRegisterNativesULeapGesture()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapGesture::StaticClass(), "Frame",(Native)&ULeapGesture::execFrame);
		FNativeFunctionRegistrar::RegisterFunction(ULeapGesture::StaticClass(), "Hands",(Native)&ULeapGesture::execHands);
		FNativeFunctionRegistrar::RegisterFunction(ULeapGesture::StaticClass(), "Pointables",(Native)&ULeapGesture::execPointables);
	}
	IMPLEMENT_CLASS(ULeapGesture, 2515773530);
	void ULeapController::StaticRegisterNativesULeapController()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapController::StaticClass(), "EnableBackgroundTracking",(Native)&ULeapController::execEnableBackgroundTracking);
		FNativeFunctionRegistrar::RegisterFunction(ULeapController::StaticClass(), "EnableGesture",(Native)&ULeapController::execEnableGesture);
		FNativeFunctionRegistrar::RegisterFunction(ULeapController::StaticClass(), "EnableImageSupport",(Native)&ULeapController::execEnableImageSupport);
		FNativeFunctionRegistrar::RegisterFunction(ULeapController::StaticClass(), "Frame",(Native)&ULeapController::execFrame);
		FNativeFunctionRegistrar::RegisterFunction(ULeapController::StaticClass(), "HasFocus",(Native)&ULeapController::execHasFocus);
		FNativeFunctionRegistrar::RegisterFunction(ULeapController::StaticClass(), "IsConnected",(Native)&ULeapController::execIsConnected);
		FNativeFunctionRegistrar::RegisterFunction(ULeapController::StaticClass(), "IsServiceConnected",(Native)&ULeapController::execIsServiceConnected);
		FNativeFunctionRegistrar::RegisterFunction(ULeapController::StaticClass(), "OptimizeForHMD",(Native)&ULeapController::execOptimizeForHMD);
		FNativeFunctionRegistrar::RegisterFunction(ULeapController::StaticClass(), "SetInterfaceDelegate",(Native)&ULeapController::execSetInterfaceDelegate);
		FNativeFunctionRegistrar::RegisterFunction(ULeapController::StaticClass(), "SetLeapMountToHMDOffset",(Native)&ULeapController::execSetLeapMountToHMDOffset);
	}
	IMPLEMENT_CLASS(ULeapController, 1967564720);
	void ILeapEventInterface::CircleGestureDetected(ULeapCircleGesture* gesture)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_CircleGestureDetected instead.");
	}
	void ILeapEventInterface::FingerCountChanged(int32 count)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_FingerCountChanged instead.");
	}
	void ILeapEventInterface::GestureDetected(ULeapGesture* gesture)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GestureDetected instead.");
	}
	void ILeapEventInterface::HandCountChanged(int32 count)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_HandCountChanged instead.");
	}
	void ILeapEventInterface::KeyTapGestureDetected(ULeapKeyTapGesture* gesture)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_KeyTapGestureDetected instead.");
	}
	void ILeapEventInterface::LeapFingerMoved(ULeapFinger* finger)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_LeapFingerMoved instead.");
	}
	void ILeapEventInterface::LeapFrontFingerTouch(ULeapFinger* finger)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_LeapFrontFingerTouch instead.");
	}
	void ILeapEventInterface::LeapFrontMostFingerMoved(ULeapFinger* finger)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_LeapFrontMostFingerMoved instead.");
	}
	void ILeapEventInterface::LeapHandGrabbed(float strength, ULeapHand* hand)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_LeapHandGrabbed instead.");
	}
	void ILeapEventInterface::LeapHandGrabbing(float strength, ULeapHand* hand)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_LeapHandGrabbing instead.");
	}
	void ILeapEventInterface::LeapHandMoved(ULeapHand* hand)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_LeapHandMoved instead.");
	}
	void ILeapEventInterface::LeapHandPinched(float strength, ULeapHand* hand)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_LeapHandPinched instead.");
	}
	void ILeapEventInterface::LeapHandPinching(float strength, ULeapHand* hand)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_LeapHandPinching instead.");
	}
	void ILeapEventInterface::LeapHandReleased(float strength, ULeapHand* hand)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_LeapHandReleased instead.");
	}
	void ILeapEventInterface::LeapHandUnpinched(float strength, ULeapHand* hand)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_LeapHandUnpinched instead.");
	}
	void ILeapEventInterface::LeapLeftHandMoved(ULeapHand* hand)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_LeapLeftHandMoved instead.");
	}
	void ILeapEventInterface::LeapLeftMostFingerMoved(ULeapFinger* finger)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_LeapLeftMostFingerMoved instead.");
	}
	void ILeapEventInterface::LeapRightHandMoved(ULeapHand* hand)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_LeapRightHandMoved instead.");
	}
	void ILeapEventInterface::LeapRightMostFingerMoved(ULeapFinger* finger)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_LeapRightMostFingerMoved instead.");
	}
	void ILeapEventInterface::RawImageReceived(UTexture2D* texture, ULeapImage* image)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_RawImageReceived instead.");
	}
	void ILeapEventInterface::ScreenTapGestureDetected(ULeapScreenTapGesture* gesture)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_ScreenTapGestureDetected instead.");
	}
	void ILeapEventInterface::SwipeGestureDetected(ULeapSwipeGesture* gesture)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_SwipeGestureDetected instead.");
	}
	void ULeapEventInterface::StaticRegisterNativesULeapEventInterface()
	{
	}
	IMPLEMENT_CLASS(ULeapEventInterface, 1239986348);
	void ILeapEventInterface::Execute_CircleGestureDetected(UObject* O, ULeapCircleGesture* gesture)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventCircleGestureDetected_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_CircleGestureDetected);
		if (Func)
		{
			Parms.gesture=gesture;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_FingerCountChanged(UObject* O, int32 count)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventFingerCountChanged_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_FingerCountChanged);
		if (Func)
		{
			Parms.count=count;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_GestureDetected(UObject* O, ULeapGesture* gesture)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventGestureDetected_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_GestureDetected);
		if (Func)
		{
			Parms.gesture=gesture;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_HandCountChanged(UObject* O, int32 count)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventHandCountChanged_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_HandCountChanged);
		if (Func)
		{
			Parms.count=count;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_KeyTapGestureDetected(UObject* O, ULeapKeyTapGesture* gesture)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventKeyTapGestureDetected_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_KeyTapGestureDetected);
		if (Func)
		{
			Parms.gesture=gesture;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_LeapFingerMoved(UObject* O, ULeapFinger* finger)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventLeapFingerMoved_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_LeapFingerMoved);
		if (Func)
		{
			Parms.finger=finger;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_LeapFrontFingerTouch(UObject* O, ULeapFinger* finger)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventLeapFrontFingerTouch_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_LeapFrontFingerTouch);
		if (Func)
		{
			Parms.finger=finger;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_LeapFrontMostFingerMoved(UObject* O, ULeapFinger* finger)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventLeapFrontMostFingerMoved_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_LeapFrontMostFingerMoved);
		if (Func)
		{
			Parms.finger=finger;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_LeapHandGrabbed(UObject* O, float strength, ULeapHand* hand)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventLeapHandGrabbed_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_LeapHandGrabbed);
		if (Func)
		{
			Parms.strength=strength;
			Parms.hand=hand;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_LeapHandGrabbing(UObject* O, float strength, ULeapHand* hand)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventLeapHandGrabbing_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_LeapHandGrabbing);
		if (Func)
		{
			Parms.strength=strength;
			Parms.hand=hand;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_LeapHandMoved(UObject* O, ULeapHand* hand)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventLeapHandMoved_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_LeapHandMoved);
		if (Func)
		{
			Parms.hand=hand;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_LeapHandPinched(UObject* O, float strength, ULeapHand* hand)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventLeapHandPinched_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_LeapHandPinched);
		if (Func)
		{
			Parms.strength=strength;
			Parms.hand=hand;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_LeapHandPinching(UObject* O, float strength, ULeapHand* hand)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventLeapHandPinching_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_LeapHandPinching);
		if (Func)
		{
			Parms.strength=strength;
			Parms.hand=hand;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_LeapHandReleased(UObject* O, float strength, ULeapHand* hand)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventLeapHandReleased_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_LeapHandReleased);
		if (Func)
		{
			Parms.strength=strength;
			Parms.hand=hand;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_LeapHandUnpinched(UObject* O, float strength, ULeapHand* hand)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventLeapHandUnpinched_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_LeapHandUnpinched);
		if (Func)
		{
			Parms.strength=strength;
			Parms.hand=hand;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_LeapLeftHandMoved(UObject* O, ULeapHand* hand)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventLeapLeftHandMoved_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_LeapLeftHandMoved);
		if (Func)
		{
			Parms.hand=hand;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_LeapLeftMostFingerMoved(UObject* O, ULeapFinger* finger)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventLeapLeftMostFingerMoved_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_LeapLeftMostFingerMoved);
		if (Func)
		{
			Parms.finger=finger;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_LeapRightHandMoved(UObject* O, ULeapHand* hand)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventLeapRightHandMoved_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_LeapRightHandMoved);
		if (Func)
		{
			Parms.hand=hand;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_LeapRightMostFingerMoved(UObject* O, ULeapFinger* finger)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventLeapRightMostFingerMoved_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_LeapRightMostFingerMoved);
		if (Func)
		{
			Parms.finger=finger;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_RawImageReceived(UObject* O, UTexture2D* texture, ULeapImage* image)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventRawImageReceived_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_RawImageReceived);
		if (Func)
		{
			Parms.texture=texture;
			Parms.image=image;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_ScreenTapGestureDetected(UObject* O, ULeapScreenTapGesture* gesture)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventScreenTapGestureDetected_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_ScreenTapGestureDetected);
		if (Func)
		{
			Parms.gesture=gesture;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ILeapEventInterface::Execute_SwipeGestureDetected(UObject* O, ULeapSwipeGesture* gesture)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(ULeapEventInterface::StaticClass()));
		LeapEventInterface_eventSwipeGestureDetected_Parms Parms;
		UFunction* const Func = O->FindFunction(LEAPMOTION_SwipeGestureDetected);
		if (Func)
		{
			Parms.gesture=gesture;
			O->ProcessEvent(Func, &Parms);
		}
	}
	void ULeapFingerList::StaticRegisterNativesULeapFingerList()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapFingerList::StaticClass(), "Append",(Native)&ULeapFingerList::execAppend);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFingerList::StaticClass(), "Extended",(Native)&ULeapFingerList::execExtended);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFingerList::StaticClass(), "Frontmost",(Native)&ULeapFingerList::execFrontmost);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFingerList::StaticClass(), "GetPointableById",(Native)&ULeapFingerList::execGetPointableById);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFingerList::StaticClass(), "Leftmost",(Native)&ULeapFingerList::execLeftmost);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFingerList::StaticClass(), "Rightmost",(Native)&ULeapFingerList::execRightmost);
	}
	IMPLEMENT_CLASS(ULeapFingerList, 1017221764);
	void ULeapFrame::StaticRegisterNativesULeapFrame()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "Finger",(Native)&ULeapFrame::execFinger);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "Fingers",(Native)&ULeapFrame::execFingers);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "Gesture",(Native)&ULeapFrame::execGesture);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "Gestures",(Native)&ULeapFrame::execGestures);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "GesturesSinceFrame",(Native)&ULeapFrame::execGesturesSinceFrame);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "Hand",(Native)&ULeapFrame::execHand);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "Hands",(Native)&ULeapFrame::execHands);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "Images",(Native)&ULeapFrame::execImages);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "InteractionBox",(Native)&ULeapFrame::execInteractionBox);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "Pointable",(Native)&ULeapFrame::execPointable);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "Pointables",(Native)&ULeapFrame::execPointables);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "RotationAngle",(Native)&ULeapFrame::execRotationAngle);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "RotationAngleAroundAxis",(Native)&ULeapFrame::execRotationAngleAroundAxis);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "RotationAxis",(Native)&ULeapFrame::execRotationAxis);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "RotationProbability",(Native)&ULeapFrame::execRotationProbability);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "ScaleFactor",(Native)&ULeapFrame::execScaleFactor);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "ScaleProbability",(Native)&ULeapFrame::execScaleProbability);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "Tool",(Native)&ULeapFrame::execTool);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "Tools",(Native)&ULeapFrame::execTools);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "Translation",(Native)&ULeapFrame::execTranslation);
		FNativeFunctionRegistrar::RegisterFunction(ULeapFrame::StaticClass(), "TranslationProbability",(Native)&ULeapFrame::execTranslationProbability);
	}
	IMPLEMENT_CLASS(ULeapFrame, 2511409357);
	void ULeapCircleGesture::StaticRegisterNativesULeapCircleGesture()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapCircleGesture::StaticClass(), "Pointable",(Native)&ULeapCircleGesture::execPointable);
	}
	IMPLEMENT_CLASS(ULeapCircleGesture, 2774274994);
	void ULeapKeyTapGesture::StaticRegisterNativesULeapKeyTapGesture()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapKeyTapGesture::StaticClass(), "Pointable",(Native)&ULeapKeyTapGesture::execPointable);
	}
	IMPLEMENT_CLASS(ULeapKeyTapGesture, 3750365107);
	void ULeapScreenTapGesture::StaticRegisterNativesULeapScreenTapGesture()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapScreenTapGesture::StaticClass(), "Pointable",(Native)&ULeapScreenTapGesture::execPointable);
	}
	IMPLEMENT_CLASS(ULeapScreenTapGesture, 567070258);
	void ULeapSwipeGesture::StaticRegisterNativesULeapSwipeGesture()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapSwipeGesture::StaticClass(), "Pointable",(Native)&ULeapSwipeGesture::execPointable);
	}
	IMPLEMENT_CLASS(ULeapSwipeGesture, 1089539320);
	void ULeapGestureList::StaticRegisterNativesULeapGestureList()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapGestureList::StaticClass(), "GetIndex",(Native)&ULeapGestureList::execGetIndex);
	}
	IMPLEMENT_CLASS(ULeapGestureList, 700699083);
	void ULeapHandList::StaticRegisterNativesULeapHandList()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapHandList::StaticClass(), "Frontmost",(Native)&ULeapHandList::execFrontmost);
		FNativeFunctionRegistrar::RegisterFunction(ULeapHandList::StaticClass(), "GetIndex",(Native)&ULeapHandList::execGetIndex);
		FNativeFunctionRegistrar::RegisterFunction(ULeapHandList::StaticClass(), "Leftmost",(Native)&ULeapHandList::execLeftmost);
		FNativeFunctionRegistrar::RegisterFunction(ULeapHandList::StaticClass(), "Rightmost",(Native)&ULeapHandList::execRightmost);
	}
	IMPLEMENT_CLASS(ULeapHandList, 1262985910);
	void ULeapImage::StaticRegisterNativesULeapImage()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapImage::StaticClass(), "Distortion",(Native)&ULeapImage::execDistortion);
		FNativeFunctionRegistrar::RegisterFunction(ULeapImage::StaticClass(), "DistortionUE",(Native)&ULeapImage::execDistortionUE);
		FNativeFunctionRegistrar::RegisterFunction(ULeapImage::StaticClass(), "Rectify",(Native)&ULeapImage::execRectify);
		FNativeFunctionRegistrar::RegisterFunction(ULeapImage::StaticClass(), "Texture",(Native)&ULeapImage::execTexture);
		FNativeFunctionRegistrar::RegisterFunction(ULeapImage::StaticClass(), "Warp",(Native)&ULeapImage::execWarp);
	}
	IMPLEMENT_CLASS(ULeapImage, 285710473);
	void ULeapImageList::StaticRegisterNativesULeapImageList()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapImageList::StaticClass(), "GetIndex",(Native)&ULeapImageList::execGetIndex);
	}
	IMPLEMENT_CLASS(ULeapImageList, 1574328033);
	void ULeapInteractionBox::StaticRegisterNativesULeapInteractionBox()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapInteractionBox::StaticClass(), "DenormalizePoint",(Native)&ULeapInteractionBox::execDenormalizePoint);
		FNativeFunctionRegistrar::RegisterFunction(ULeapInteractionBox::StaticClass(), "NormalizePoint",(Native)&ULeapInteractionBox::execNormalizePoint);
	}
	IMPLEMENT_CLASS(ULeapInteractionBox, 179793023);
	void ULeapPointable::StaticRegisterNativesULeapPointable()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapPointable::StaticClass(), "Different",(Native)&ULeapPointable::execDifferent);
		FNativeFunctionRegistrar::RegisterFunction(ULeapPointable::StaticClass(), "Equal",(Native)&ULeapPointable::execEqual);
		FNativeFunctionRegistrar::RegisterFunction(ULeapPointable::StaticClass(), "Frame",(Native)&ULeapPointable::execFrame);
		FNativeFunctionRegistrar::RegisterFunction(ULeapPointable::StaticClass(), "Hand",(Native)&ULeapPointable::execHand);
	}
	IMPLEMENT_CLASS(ULeapPointable, 1221156053);
	void ULeapFinger::StaticRegisterNativesULeapFinger()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapFinger::StaticClass(), "Bone",(Native)&ULeapFinger::execBone);
	}
	IMPLEMENT_CLASS(ULeapFinger, 3773819773);
	void ULeapTool::StaticRegisterNativesULeapTool()
	{
	}
	IMPLEMENT_CLASS(ULeapTool, 909760504);
	void ULeapPointableList::StaticRegisterNativesULeapPointableList()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapPointableList::StaticClass(), "Append",(Native)&ULeapPointableList::execAppend);
		FNativeFunctionRegistrar::RegisterFunction(ULeapPointableList::StaticClass(), "AppendFingers",(Native)&ULeapPointableList::execAppendFingers);
		FNativeFunctionRegistrar::RegisterFunction(ULeapPointableList::StaticClass(), "AppendTools",(Native)&ULeapPointableList::execAppendTools);
		FNativeFunctionRegistrar::RegisterFunction(ULeapPointableList::StaticClass(), "Extended",(Native)&ULeapPointableList::execExtended);
		FNativeFunctionRegistrar::RegisterFunction(ULeapPointableList::StaticClass(), "Frontmost",(Native)&ULeapPointableList::execFrontmost);
		FNativeFunctionRegistrar::RegisterFunction(ULeapPointableList::StaticClass(), "GetPointableByIndex",(Native)&ULeapPointableList::execGetPointableByIndex);
		FNativeFunctionRegistrar::RegisterFunction(ULeapPointableList::StaticClass(), "Leftmost",(Native)&ULeapPointableList::execLeftmost);
		FNativeFunctionRegistrar::RegisterFunction(ULeapPointableList::StaticClass(), "Rightmost",(Native)&ULeapPointableList::execRightmost);
	}
	IMPLEMENT_CLASS(ULeapPointableList, 60921993);
	void ULeapToolList::StaticRegisterNativesULeapToolList()
	{
		FNativeFunctionRegistrar::RegisterFunction(ULeapToolList::StaticClass(), "Append",(Native)&ULeapToolList::execAppend);
		FNativeFunctionRegistrar::RegisterFunction(ULeapToolList::StaticClass(), "Count",(Native)&ULeapToolList::execCount);
		FNativeFunctionRegistrar::RegisterFunction(ULeapToolList::StaticClass(), "Frontmost",(Native)&ULeapToolList::execFrontmost);
		FNativeFunctionRegistrar::RegisterFunction(ULeapToolList::StaticClass(), "GetPointableByIndex",(Native)&ULeapToolList::execGetPointableByIndex);
		FNativeFunctionRegistrar::RegisterFunction(ULeapToolList::StaticClass(), "IsEmpty",(Native)&ULeapToolList::execIsEmpty);
		FNativeFunctionRegistrar::RegisterFunction(ULeapToolList::StaticClass(), "Leftmost",(Native)&ULeapToolList::execLeftmost);
		FNativeFunctionRegistrar::RegisterFunction(ULeapToolList::StaticClass(), "Rightmost",(Native)&ULeapToolList::execRightmost);
	}
	IMPLEMENT_CLASS(ULeapToolList, 1147559282);
#if USE_COMPILED_IN_NATIVES
// Cross Module References
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FRotator();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FTransform();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector();
	COREUOBJECT_API class UClass* Z_Construct_UClass_UObject();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FMatrix();
	ENGINE_API class UClass* Z_Construct_UClass_UActorComponent();
	COREUOBJECT_API class UClass* Z_Construct_UClass_UObject_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UTexture2D_NoRegister();

	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimBone_ChangeBasis();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimBone_Enabled();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimBone_GetTransform();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimBone_SetEnabled();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimBone_SetFromTransform();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimBone_TranslateBone();
	LEAPMOTION_API class UClass* Z_Construct_UClass_UAnimBone_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_UAnimBone();
	LEAPMOTION_API class UEnum* Z_Construct_UEnum_LeapMotion_LeapZone();
	LEAPMOTION_API class UEnum* Z_Construct_UEnum_LeapMotion_LeapHandType();
	LEAPMOTION_API class UEnum* Z_Construct_UEnum_LeapMotion_LeapBasicDirection();
	LEAPMOTION_API class UEnum* Z_Construct_UEnum_LeapMotion_LeapGestureState();
	LEAPMOTION_API class UEnum* Z_Construct_UEnum_LeapMotion_LeapGestureType();
	LEAPMOTION_API class UEnum* Z_Construct_UEnum_LeapMotion_LeapBoneType();
	LEAPMOTION_API class UEnum* Z_Construct_UEnum_LeapMotion_LeapFingerType();
	LEAPMOTION_API class UEnum* Z_Construct_UEnum_LeapMotion_AnimHandType();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimFinger_ChangeBasis();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimFinger_Enabled();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimFinger_SetEnabled();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimFinger_SetFromLeapFinger();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimFinger_TranslateFinger();
	LEAPMOTION_API class UClass* Z_Construct_UClass_UAnimFinger_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_UAnimFinger();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapHand_Fingers();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapHand_Frame();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapHand_RotationAngle();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapHand_RotationAngleWithAxis();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapHand_RotationAxis();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapHand_RotationMatrix();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapHand_RotationProbability();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapHand_ScaleFactor();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapHand_ScaleProbability();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapHand_Translation();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapHand_TranslationProbability();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapHand_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapHand();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimHand_ChangeBasis();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimHand_Enabled();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimHand_SetEnabled();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimHand_SetFromLeapHand();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimHand_TranslateHand();
	LEAPMOTION_API class UClass* Z_Construct_UClass_UAnimHand_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_UAnimHand();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimBody_ChangeBasis();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimBody_Enabled();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimBody_SetEnabled();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_UAnimBody_TranslateBody();
	LEAPMOTION_API class UClass* Z_Construct_UClass_UAnimBody_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_UAnimBody();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapArm_GetOrientation();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapArm_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapArm();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapBaseObject_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapBaseObject();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapBone_Different();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapBone_Equal();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapBone_GetOrientation();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapBone_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapBone();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapGesture_Frame();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapGesture_Hands();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapGesture_Pointables();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapGesture_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapGesture();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapController_EnableBackgroundTracking();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapController_EnableGesture();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapController_EnableImageSupport();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapController_Frame();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapController_HasFocus();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapController_IsConnected();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapController_IsServiceConnected();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapController_OptimizeForHMD();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapController_SetInterfaceDelegate();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapController_SetLeapMountToHMDOffset();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapController_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapController();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_CircleGestureDetected();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_FingerCountChanged();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_GestureDetected();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_HandCountChanged();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_KeyTapGestureDetected();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapFingerMoved();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapFrontFingerTouch();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapFrontMostFingerMoved();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapHandGrabbed();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapHandGrabbing();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapHandMoved();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapHandPinched();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapHandPinching();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapHandReleased();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapHandUnpinched();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapLeftHandMoved();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapLeftMostFingerMoved();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapRightHandMoved();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapRightMostFingerMoved();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_RawImageReceived();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_ScreenTapGestureDetected();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapEventInterface_SwipeGestureDetected();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapEventInterface_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapEventInterface();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFingerList_Append();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFingerList_Extended();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFingerList_Frontmost();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFingerList_GetPointableById();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFingerList_Leftmost();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFingerList_Rightmost();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapFingerList_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapFingerList();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_Finger();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_Fingers();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_Gesture();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_Gestures();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_GesturesSinceFrame();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_Hand();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_Hands();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_Images();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_InteractionBox();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_Pointable();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_Pointables();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_RotationAngle();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_RotationAngleAroundAxis();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_RotationAxis();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_RotationProbability();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_ScaleFactor();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_ScaleProbability();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_Tool();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_Tools();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_Translation();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFrame_TranslationProbability();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapFrame_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapFrame();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapCircleGesture_Pointable();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapCircleGesture_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapCircleGesture();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapKeyTapGesture_Pointable();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapKeyTapGesture_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapKeyTapGesture();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapScreenTapGesture_Pointable();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapScreenTapGesture_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapScreenTapGesture();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapSwipeGesture_Pointable();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapSwipeGesture_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapSwipeGesture();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapGestureList_GetIndex();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapGestureList_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapGestureList();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapHandList_Frontmost();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapHandList_GetIndex();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapHandList_Leftmost();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapHandList_Rightmost();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapHandList_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapHandList();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapImage_Distortion();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapImage_DistortionUE();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapImage_Rectify();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapImage_Texture();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapImage_Warp();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapImage_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapImage();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapImageList_GetIndex();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapImageList_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapImageList();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapInteractionBox_DenormalizePoint();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapInteractionBox_NormalizePoint();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapInteractionBox_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapInteractionBox();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapPointable_Different();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapPointable_Equal();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapPointable_Frame();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapPointable_Hand();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapPointable_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapPointable();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapFinger_Bone();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapFinger_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapFinger();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapTool_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapTool();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapPointableList_Append();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapPointableList_AppendFingers();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapPointableList_AppendTools();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapPointableList_Extended();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapPointableList_Frontmost();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapPointableList_GetPointableByIndex();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapPointableList_Leftmost();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapPointableList_Rightmost();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapPointableList_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapPointableList();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapToolList_Append();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapToolList_Count();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapToolList_Frontmost();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapToolList_GetPointableByIndex();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapToolList_IsEmpty();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapToolList_Leftmost();
	LEAPMOTION_API class UFunction* Z_Construct_UFunction_ULeapToolList_Rightmost();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapToolList_NoRegister();
	LEAPMOTION_API class UClass* Z_Construct_UClass_ULeapToolList();
	LEAPMOTION_API class UPackage* Z_Construct_UPackage__Script_LeapMotion();
	UFunction* Z_Construct_UFunction_UAnimBone_ChangeBasis()
	{
		struct AnimBone_eventChangeBasis_Parms
		{
			FRotator PreBase;
			FRotator PostBase;
			bool AdjustVectors;
		};
		UObject* Outer=Z_Construct_UClass_UAnimBone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ChangeBasis"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(AnimBone_eventChangeBasis_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(AdjustVectors, AnimBone_eventChangeBasis_Parms, bool);
			UProperty* NewProp_AdjustVectors = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AdjustVectors"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(AdjustVectors, AnimBone_eventChangeBasis_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(AdjustVectors, AnimBone_eventChangeBasis_Parms), sizeof(bool), true);
			UProperty* NewProp_PostBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PostBase"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PostBase, AnimBone_eventChangeBasis_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_PreBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PreBase"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PreBase, AnimBone_eventChangeBasis_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Bone"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_AdjustVectors"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBone.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAnimBone_Enabled()
	{
		struct AnimBone_eventEnabled_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAnimBone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Enabled"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AnimBone_eventEnabled_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AnimBone_eventEnabled_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AnimBone_eventEnabled_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AnimBone_eventEnabled_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Bone"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBone.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAnimBone_GetTransform()
	{
		struct AnimBone_eventGetTransform_Parms
		{
			FTransform ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAnimBone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x14820401, 65535, sizeof(AnimBone_eventGetTransform_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, AnimBone_eventGetTransform_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FTransform());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Bone"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBone.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAnimBone_SetEnabled()
	{
		struct AnimBone_eventSetEnabled_Parms
		{
			bool Enable;
		};
		UObject* Outer=Z_Construct_UClass_UAnimBone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetEnabled"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AnimBone_eventSetEnabled_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(Enable, AnimBone_eventSetEnabled_Parms, bool);
			UProperty* NewProp_Enable = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Enable"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(Enable, AnimBone_eventSetEnabled_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(Enable, AnimBone_eventSetEnabled_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Bone"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_Enable"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBone.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAnimBone_SetFromTransform()
	{
		struct AnimBone_eventSetFromTransform_Parms
		{
			FTransform Transform;
		};
		UObject* Outer=Z_Construct_UClass_UAnimBone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetFromTransform"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(AnimBone_eventSetFromTransform_Parms));
			UProperty* NewProp_Transform = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Transform"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Transform, AnimBone_eventSetFromTransform_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FTransform());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Bone"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBone.h"));
			MetaData->SetValue(NewProp_Transform, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAnimBone_TranslateBone()
	{
		struct AnimBone_eventTranslateBone_Parms
		{
			FVector Shift;
		};
		UObject* Outer=Z_Construct_UClass_UAnimBone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TranslateBone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(AnimBone_eventTranslateBone_Parms));
			UProperty* NewProp_Shift = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Shift"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Shift, AnimBone_eventTranslateBone_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Bone"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBone.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAnimBone_NoRegister()
	{
		return UAnimBone::StaticClass();
	}
	UClass* Z_Construct_UClass_UAnimBone()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = UAnimBone::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20000080;

				OuterClass->LinkChild(Z_Construct_UFunction_UAnimBone_ChangeBasis());
				OuterClass->LinkChild(Z_Construct_UFunction_UAnimBone_Enabled());
				OuterClass->LinkChild(Z_Construct_UFunction_UAnimBone_GetTransform());
				OuterClass->LinkChild(Z_Construct_UFunction_UAnimBone_SetEnabled());
				OuterClass->LinkChild(Z_Construct_UFunction_UAnimBone_SetFromTransform());
				OuterClass->LinkChild(Z_Construct_UFunction_UAnimBone_TranslateBone());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PrevJoint = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PrevJoint"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PrevJoint, UAnimBone), 0x0010000000000004, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_NextJoint = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NextJoint"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(NextJoint, UAnimBone), 0x0010000000000004, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Alpha = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Alpha"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Alpha, UAnimBone), 0x0010000000000004);
				UProperty* NewProp_Length = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Length"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Length, UAnimBone), 0x0010000000000004);
				UProperty* NewProp_Scale = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Scale"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Scale, UAnimBone), 0x0010000000000004, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Orientation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Orientation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Orientation, UAnimBone), 0x0010000000000004, Z_Construct_UScriptStruct_FRotator());
				UProperty* NewProp_Position = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Position"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Position, UAnimBone), 0x0010000000000004, Z_Construct_UScriptStruct_FVector());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimBone_ChangeBasis(), "ChangeBasis"); // 277620248
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimBone_Enabled(), "Enabled"); // 216277294
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimBone_GetTransform(), "GetTransform"); // 1741561789
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimBone_SetEnabled(), "SetEnabled"); // 3667510945
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimBone_SetFromTransform(), "SetFromTransform"); // 1304242947
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimBone_TranslateBone(), "TranslateBone"); // 322600608
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("AnimBody/AnimBone.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBone.h"));
				MetaData->SetValue(NewProp_PrevJoint, TEXT("Category"), TEXT("Anim Bone"));
				MetaData->SetValue(NewProp_PrevJoint, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBone.h"));
				MetaData->SetValue(NewProp_PrevJoint, TEXT("ToolTip"), TEXT("Optional vector of the previous joint (inward)"));
				MetaData->SetValue(NewProp_NextJoint, TEXT("Category"), TEXT("Anim Bone"));
				MetaData->SetValue(NewProp_NextJoint, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBone.h"));
				MetaData->SetValue(NewProp_NextJoint, TEXT("ToolTip"), TEXT("Optional vector of the next joint (outward)"));
				MetaData->SetValue(NewProp_Alpha, TEXT("Category"), TEXT("Anim Bone"));
				MetaData->SetValue(NewProp_Alpha, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBone.h"));
				MetaData->SetValue(NewProp_Length, TEXT("Category"), TEXT("Anim Bone"));
				MetaData->SetValue(NewProp_Length, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBone.h"));
				MetaData->SetValue(NewProp_Scale, TEXT("Category"), TEXT("Anim Bone"));
				MetaData->SetValue(NewProp_Scale, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBone.h"));
				MetaData->SetValue(NewProp_Orientation, TEXT("Category"), TEXT("Anim Bone"));
				MetaData->SetValue(NewProp_Orientation, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBone.h"));
				MetaData->SetValue(NewProp_Position, TEXT("Category"), TEXT("Anim Bone"));
				MetaData->SetValue(NewProp_Position, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBone.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAnimBone(Z_Construct_UClass_UAnimBone, &UAnimBone::StaticClass, TEXT("UAnimBone"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAnimBone);
	UEnum* Z_Construct_UEnum_LeapMotion_LeapZone()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_LeapMotion();
		extern uint32 Get_Z_Construct_UEnum_LeapMotion_LeapZone_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("LeapZone"), 0, Get_Z_Construct_UEnum_LeapMotion_LeapZone_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapZone"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ZONE_ERROR")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ZONE_NONE")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ZONE_HOVERING")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ZONE_TOUCHING")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ZONE_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("LeapZone");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/LeapEnums.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_LeapMotion_LeapZone_CRC() { return 2158995491U; }
	UEnum* Z_Construct_UEnum_LeapMotion_LeapHandType()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_LeapMotion();
		extern uint32 Get_Z_Construct_UEnum_LeapMotion_LeapHandType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("LeapHandType"), 0, Get_Z_Construct_UEnum_LeapMotion_LeapHandType_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapHandType"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("HAND_UNKNOWN")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("HAND_LEFT")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("HAND_RIGHT")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("HAND_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("LeapHandType");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/LeapEnums.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_LeapMotion_LeapHandType_CRC() { return 3657048639U; }
	UEnum* Z_Construct_UEnum_LeapMotion_LeapBasicDirection()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_LeapMotion();
		extern uint32 Get_Z_Construct_UEnum_LeapMotion_LeapBasicDirection_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("LeapBasicDirection"), 0, Get_Z_Construct_UEnum_LeapMotion_LeapBasicDirection_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapBasicDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DIRECTION_NONE")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DIRECTION_LEFT")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DIRECTION_RIGHT")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DIRECTION_UP")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DIRECTION_DOWN")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DIRECTION_AWAY")), 5));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DIRECTION_TOWARD")), 6));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("DIRECTION_MAX")), 7));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("LeapBasicDirection");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/LeapEnums.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_LeapMotion_LeapBasicDirection_CRC() { return 3875280241U; }
	UEnum* Z_Construct_UEnum_LeapMotion_LeapGestureState()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_LeapMotion();
		extern uint32 Get_Z_Construct_UEnum_LeapMotion_LeapGestureState_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("LeapGestureState"), 0, Get_Z_Construct_UEnum_LeapMotion_LeapGestureState_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapGestureState"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("GESTURE_STATE_INVALID")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("GESTURE_STATE_START")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("GESTURE_STATE_UPDATE")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("GESTURE_STATE_STOP")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("GESTURE_STATE_MAX")), 4));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("LeapGestureState");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/LeapEnums.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_LeapMotion_LeapGestureState_CRC() { return 625048044U; }
	UEnum* Z_Construct_UEnum_LeapMotion_LeapGestureType()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_LeapMotion();
		extern uint32 Get_Z_Construct_UEnum_LeapMotion_LeapGestureType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("LeapGestureType"), 0, Get_Z_Construct_UEnum_LeapMotion_LeapGestureType_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapGestureType"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("GESTURE_TYPE_INVALID")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("GESTURE_TYPE_SWIPE")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("GESTURE_TYPE_CIRCLE")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("GESTURE_TYPE_SCREEN_TAP")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("GESTURE_TYPE_KEY_TAP")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("GESTURE_TYPE_MAX")), 5));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("LeapGestureType");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/LeapEnums.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_LeapMotion_LeapGestureType_CRC() { return 1521395200U; }
	UEnum* Z_Construct_UEnum_LeapMotion_LeapBoneType()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_LeapMotion();
		extern uint32 Get_Z_Construct_UEnum_LeapMotion_LeapBoneType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("LeapBoneType"), 0, Get_Z_Construct_UEnum_LeapMotion_LeapBoneType_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapBoneType"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("TYPE_METACARPAL")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("TYPE_PROXIMAL")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("TYPE_INTERMEDIATE")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("TYPE_DISTAL")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("TYPE_ERROR")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("TYPE_MAX")), 5));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("LeapBoneType");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/LeapEnums.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_LeapMotion_LeapBoneType_CRC() { return 3149085250U; }
	UEnum* Z_Construct_UEnum_LeapMotion_LeapFingerType()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_LeapMotion();
		extern uint32 Get_Z_Construct_UEnum_LeapMotion_LeapFingerType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("LeapFingerType"), 0, Get_Z_Construct_UEnum_LeapMotion_LeapFingerType_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapFingerType"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FINGER_TYPE_THUMB")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FINGER_TYPE_INDEX")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FINGER_TYPE_MIDDLE")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FINGER_TYPE_RING")), 3));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FINGER_TYPE_PINKY")), 4));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("FINGER_TYPE_MAX")), 5));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("LeapFingerType");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/LeapEnums.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_LeapMotion_LeapFingerType_CRC() { return 4158759446U; }
	UEnum* Z_Construct_UEnum_LeapMotion_AnimHandType()
	{
		UPackage* Outer=Z_Construct_UPackage__Script_LeapMotion();
		extern uint32 Get_Z_Construct_UEnum_LeapMotion_AnimHandType_CRC();
		static UEnum* ReturnEnum = FindExistingEnumIfHotReloadOrDynamic(Outer, TEXT("AnimHandType"), 0, Get_Z_Construct_UEnum_LeapMotion_AnimHandType_CRC(), false);
		if (!ReturnEnum)
		{
			ReturnEnum = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AnimHandType"), RF_Public|RF_Transient|RF_MarkAsNative) UEnum(FObjectInitializer());
			TArray<TPair<FName, uint8>> EnumNames;
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ANIM_HAND_UNKNOWN")), 0));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ANIM_HAND_LEFT")), 1));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ANIM_HAND_RIGHT")), 2));
			EnumNames.Add(TPairInitializer<FName, uint8>(FName(TEXT("ANIM_HAND_MAX")), 3));
			ReturnEnum->SetEnums(EnumNames, UEnum::ECppForm::Regular);
			ReturnEnum->CppType = TEXT("AnimHandType");
#if WITH_METADATA
			UMetaData* MetaData = ReturnEnum->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnEnum, TEXT("BlueprintType"), TEXT("true"));
			MetaData->SetValue(ReturnEnum, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimFinger.h"));
#endif
		}
		return ReturnEnum;
	}
	uint32 Get_Z_Construct_UEnum_LeapMotion_AnimHandType_CRC() { return 955001992U; }
	UFunction* Z_Construct_UFunction_UAnimFinger_ChangeBasis()
	{
		struct AnimFinger_eventChangeBasis_Parms
		{
			FRotator PreBase;
			FRotator PostBase;
			bool AdjustVectors;
		};
		UObject* Outer=Z_Construct_UClass_UAnimFinger();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ChangeBasis"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(AnimFinger_eventChangeBasis_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(AdjustVectors, AnimFinger_eventChangeBasis_Parms, bool);
			UProperty* NewProp_AdjustVectors = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AdjustVectors"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(AdjustVectors, AnimFinger_eventChangeBasis_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(AdjustVectors, AnimFinger_eventChangeBasis_Parms), sizeof(bool), true);
			UProperty* NewProp_PostBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PostBase"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PostBase, AnimFinger_eventChangeBasis_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_PreBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PreBase"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PreBase, AnimFinger_eventChangeBasis_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Finger"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_AdjustVectors"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimFinger.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAnimFinger_Enabled()
	{
		struct AnimFinger_eventEnabled_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAnimFinger();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Enabled"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AnimFinger_eventEnabled_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AnimFinger_eventEnabled_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AnimFinger_eventEnabled_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AnimFinger_eventEnabled_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Finger"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimFinger.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAnimFinger_SetEnabled()
	{
		struct AnimFinger_eventSetEnabled_Parms
		{
			bool Enable;
		};
		UObject* Outer=Z_Construct_UClass_UAnimFinger();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetEnabled"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AnimFinger_eventSetEnabled_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(Enable, AnimFinger_eventSetEnabled_Parms, bool);
			UProperty* NewProp_Enable = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Enable"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(Enable, AnimFinger_eventSetEnabled_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(Enable, AnimFinger_eventSetEnabled_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Finger"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_Enable"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimFinger.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAnimFinger_SetFromLeapFinger()
	{
		struct AnimFinger_eventSetFromLeapFinger_Parms
		{
			ULeapFinger* Finger;
			TEnumAsByte<LeapHandType> HandType;
		};
		UObject* Outer=Z_Construct_UClass_UAnimFinger();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetFromLeapFinger"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AnimFinger_eventSetFromLeapFinger_Parms));
			UProperty* NewProp_HandType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("HandType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(HandType, AnimFinger_eventSetFromLeapFinger_Parms), 0x0010000000000080, Z_Construct_UEnum_LeapMotion_LeapHandType());
			UProperty* NewProp_Finger = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Finger"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Finger, AnimFinger_eventSetFromLeapFinger_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFinger_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Finger"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimFinger.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAnimFinger_TranslateFinger()
	{
		struct AnimFinger_eventTranslateFinger_Parms
		{
			FVector Shift;
		};
		UObject* Outer=Z_Construct_UClass_UAnimFinger();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TranslateFinger"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(AnimFinger_eventTranslateFinger_Parms));
			UProperty* NewProp_Shift = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Shift"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Shift, AnimFinger_eventTranslateFinger_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Finger"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimFinger.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAnimFinger_NoRegister()
	{
		return UAnimFinger::StaticClass();
	}
	UClass* Z_Construct_UClass_UAnimFinger()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = UAnimFinger::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20000080;

				OuterClass->LinkChild(Z_Construct_UFunction_UAnimFinger_ChangeBasis());
				OuterClass->LinkChild(Z_Construct_UFunction_UAnimFinger_Enabled());
				OuterClass->LinkChild(Z_Construct_UFunction_UAnimFinger_SetEnabled());
				OuterClass->LinkChild(Z_Construct_UFunction_UAnimFinger_SetFromLeapFinger());
				OuterClass->LinkChild(Z_Construct_UFunction_UAnimFinger_TranslateFinger());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Alpha = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Alpha"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Alpha, UAnimFinger), 0x0010000000000004);
				UProperty* NewProp_Distal = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Distal"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Distal, UAnimFinger), 0x0010000000000014, Z_Construct_UClass_UAnimBone_NoRegister());
				UProperty* NewProp_Intermediate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Intermediate"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Intermediate, UAnimFinger), 0x0010000000000014, Z_Construct_UClass_UAnimBone_NoRegister());
				UProperty* NewProp_Proximal = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Proximal"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Proximal, UAnimFinger), 0x0010000000000014, Z_Construct_UClass_UAnimBone_NoRegister());
				UProperty* NewProp_Metacarpal = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Metacarpal"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Metacarpal, UAnimFinger), 0x0010000000000014, Z_Construct_UClass_UAnimBone_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimFinger_ChangeBasis(), "ChangeBasis"); // 1105762007
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimFinger_Enabled(), "Enabled"); // 1027493869
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimFinger_SetEnabled(), "SetEnabled"); // 3727305197
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimFinger_SetFromLeapFinger(), "SetFromLeapFinger"); // 2193501317
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimFinger_TranslateFinger(), "TranslateFinger"); // 2341506331
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("AnimBody/AnimFinger.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimFinger.h"));
				MetaData->SetValue(NewProp_Alpha, TEXT("Category"), TEXT("Anim Finger"));
				MetaData->SetValue(NewProp_Alpha, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimFinger.h"));
				MetaData->SetValue(NewProp_Distal, TEXT("Category"), TEXT("Anim Finger"));
				MetaData->SetValue(NewProp_Distal, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimFinger.h"));
				MetaData->SetValue(NewProp_Intermediate, TEXT("Category"), TEXT("Anim Finger"));
				MetaData->SetValue(NewProp_Intermediate, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimFinger.h"));
				MetaData->SetValue(NewProp_Proximal, TEXT("Category"), TEXT("Anim Finger"));
				MetaData->SetValue(NewProp_Proximal, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimFinger.h"));
				MetaData->SetValue(NewProp_Metacarpal, TEXT("Category"), TEXT("Anim Finger"));
				MetaData->SetValue(NewProp_Metacarpal, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimFinger.h"));
				MetaData->SetValue(NewProp_Metacarpal, TEXT("ToolTip"), TEXT("Not used in basic animation"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAnimFinger(Z_Construct_UClass_UAnimFinger, &UAnimFinger::StaticClass, TEXT("UAnimFinger"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAnimFinger);
	UFunction* Z_Construct_UFunction_ULeapHand_Fingers()
	{
		struct LeapHand_eventFingers_Parms
		{
			ULeapFingerList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapHand();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Fingers"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapHand_eventFingers_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapHand_eventFingers_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapFingerList_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Hand"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Fingers"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The list of Finger objects detected in this frame that are attached to this hand,\ngiven in order from thumb to pinky.\n\n@return       The FingerList containing all Finger objects attached to this hand."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapHand_Frame()
	{
		struct LeapHand_eventFrame_Parms
		{
			ULeapFrame* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapHand();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Frame"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapHand_eventFrame_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapHand_eventFrame_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Hand"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The Frame associated with this Hand.\n\n@return       The associated Frame object, if available; otherwise, an invalid Frame object is returned."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapHand_RotationAngle()
	{
		struct LeapHand_eventRotationAngle_Parms
		{
			ULeapFrame* OtherFrame;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapHand();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RotationAngle"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapHand_eventRotationAngle_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, LeapHand_eventRotationAngle_Parms), 0x0010000000000580);
			UProperty* NewProp_OtherFrame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherFrame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(OtherFrame, LeapHand_eventRotationAngle_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Hand"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("RotationAngle"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The angle of rotation around the rotation axis derived from the change in orientation\nof this hand, and any associated fingers, between the current frame and the specified frame.\n\n@param        OtherFrame      The starting frame for computing the relative rotation.\n@return       A positive value representing the heuristically determined rotational change of the hand between the current frame and that specified in the sinceFrame parameter."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapHand_RotationAngleWithAxis()
	{
		struct LeapHand_eventRotationAngleWithAxis_Parms
		{
			ULeapFrame* OtherFrame;
			FVector Axis;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapHand();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RotationAngleWithAxis"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04C20401, 65535, sizeof(LeapHand_eventRotationAngleWithAxis_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, LeapHand_eventRotationAngleWithAxis_Parms), 0x0010000000000580);
			UProperty* NewProp_Axis = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Axis"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Axis, LeapHand_eventRotationAngleWithAxis_Parms), 0x0010000008000182, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_OtherFrame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherFrame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(OtherFrame, LeapHand_eventRotationAngleWithAxis_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Hand"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("RotationAngleWithAxis"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The angle of rotation around the specified axis derived from the change in orientation\nof this hand, and any associated fingers, between the current frame and the specified frame.\n\n@param        OtherFrame      The starting frame for computing the relative rotation.\n@param        Axis            The axis to measure rotation around.\n@return       A value representing the heuristically determined rotational change of the hand between the current frame and that specified in the sinceFrame parameter around the specified axis."));
			MetaData->SetValue(NewProp_Axis, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapHand_RotationAxis()
	{
		struct LeapHand_eventRotationAxis_Parms
		{
			const ULeapFrame* OtherFrame;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapHand();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RotationAxis"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(LeapHand_eventRotationAxis_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, LeapHand_eventRotationAxis_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_OtherFrame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherFrame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(OtherFrame, LeapHand_eventRotationAxis_Parms), 0x0010000000000082, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Hand"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("RotationAxis"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The axis of rotation derived from the change in orientation of this hand, and any associated\nfingers, between the current frame and the specified frame.\n\n@param        OtherFrame      The starting frame for computing the relative rotation.\n@return       A normalized direction Vector representing the heuristically determined axis of rotational change of the hand between the current frame and that specified in the sinceFrame parameter."));
			MetaData->SetValue(NewProp_OtherFrame, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapHand_RotationMatrix()
	{
		struct FMatrix
		{
			FPlane XPlane;
			FPlane YPlane;
			FPlane ZPlane;
			FPlane WPlane;
		};

		struct LeapHand_eventRotationMatrix_Parms
		{
			const ULeapFrame* OtherFrame;
			FMatrix ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapHand();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RotationMatrix"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(LeapHand_eventRotationMatrix_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, LeapHand_eventRotationMatrix_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FMatrix());
			UProperty* NewProp_OtherFrame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherFrame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(OtherFrame, LeapHand_eventRotationMatrix_Parms), 0x0010000000000082, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Hand"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("RotationMatrix"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The transform matrix expressing the rotation derived from the change in orientation of this\nhand, and any associated fingers, between the current frame and the specified frame.\n\n@param        OtherFrame      The starting frame for computing the relative rotation.\n@return       A transformation Matrix representing the heuristically determined rotational change of the hand between the current frame and that specified in the sinceFrame parameter."));
			MetaData->SetValue(NewProp_OtherFrame, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapHand_RotationProbability()
	{
		struct LeapHand_eventRotationProbability_Parms
		{
			const ULeapFrame* OtherFrame;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapHand();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RotationProbability"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapHand_eventRotationProbability_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, LeapHand_eventRotationProbability_Parms), 0x0010000000000580);
			UProperty* NewProp_OtherFrame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherFrame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(OtherFrame, LeapHand_eventRotationProbability_Parms), 0x0010000000000082, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Hand"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("RotationProbability"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The estimated probability that the hand motion between the current frame and the specified\nframe is intended to be a rotating motion.\n\n@param        OtherFrame      The starting frame for computing the relative rotation.\n@return       A value between 0 and 1 representing the estimated probability that the hand motion between the current frame and the specified frame is intended to be a rotating motion."));
			MetaData->SetValue(NewProp_OtherFrame, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapHand_ScaleFactor()
	{
		struct LeapHand_eventScaleFactor_Parms
		{
			const ULeapFrame* OtherFrame;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapHand();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ScaleFactor"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapHand_eventScaleFactor_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, LeapHand_eventScaleFactor_Parms), 0x0010000000000580);
			UProperty* NewProp_OtherFrame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherFrame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(OtherFrame, LeapHand_eventScaleFactor_Parms), 0x0010000000000082, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Hand"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("ScaleFactor"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The scale factor derived from this hand?s motion between the current frame and the specified frame.\n\n@param        OtherFrame      The starting frame for computing the relative scaling.\n@return       A positive value representing the heuristically determined scaling change ratio of the hand between the current frame and that specified in the sinceFrame parameter."));
			MetaData->SetValue(NewProp_OtherFrame, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapHand_ScaleProbability()
	{
		struct LeapHand_eventScaleProbability_Parms
		{
			const ULeapFrame* OtherFrame;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapHand();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ScaleProbability"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapHand_eventScaleProbability_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, LeapHand_eventScaleProbability_Parms), 0x0010000000000580);
			UProperty* NewProp_OtherFrame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherFrame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(OtherFrame, LeapHand_eventScaleProbability_Parms), 0x0010000000000082, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Hand"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("ScaleProbability"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The estimated probability that the hand motion between the current frame and the specified\nframe is intended to be a scaling motion.\n\n@param        OtherFrame      The starting frame for computing the relative scaling.\n@return       A value between 0 and 1 representing the estimated probability that the hand motion between the current frame and the specified frame is intended to be a scaling motion."));
			MetaData->SetValue(NewProp_OtherFrame, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapHand_Translation()
	{
		struct LeapHand_eventTranslation_Parms
		{
			const ULeapFrame* OtherFrame;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapHand();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Translation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(LeapHand_eventTranslation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, LeapHand_eventTranslation_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_OtherFrame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherFrame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(OtherFrame, LeapHand_eventTranslation_Parms), 0x0010000000000082, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Hand"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Translation"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The change of position of this hand between the current frame and the specified frame.\n\n@param        OtherFrame      The starting frame for computing the translation.\n@return       A Vector representing the heuristically determined change in hand position between the current frame and that specified in the sinceFrame parameter."));
			MetaData->SetValue(NewProp_OtherFrame, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapHand_TranslationProbability()
	{
		struct LeapHand_eventTranslationProbability_Parms
		{
			const ULeapFrame* OtherFrame;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapHand();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TranslationProbability"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapHand_eventTranslationProbability_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, LeapHand_eventTranslationProbability_Parms), 0x0010000000000580);
			UProperty* NewProp_OtherFrame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherFrame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(OtherFrame, LeapHand_eventTranslationProbability_Parms), 0x0010000000000082, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Hand"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("TranslationProbability"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The estimated probability that the hand motion between the current frame and the specified\nframe is intended to be a translating motion.\n\n@param        OtherFrame      The starting frame for computing the translation.\n@return       A value between 0 and 1 representing the estimated probability that the hand motion between the current frame and the specified frame is intended to be a translating motion."));
			MetaData->SetValue(NewProp_OtherFrame, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapHand_NoRegister()
	{
		return ULeapHand::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapHand()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapHand::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapHand_Fingers());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapHand_Frame());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapHand_RotationAngle());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapHand_RotationAngleWithAxis());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapHand_RotationAxis());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapHand_RotationMatrix());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapHand_RotationProbability());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapHand_ScaleFactor());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapHand_ScaleProbability());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapHand_Translation());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapHand_TranslationProbability());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PFingers = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PFingers"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PFingers, ULeapHand), 0x0040000000000000, Z_Construct_UClass_ULeapFingerList_NoRegister());
				UProperty* NewProp_PFrame = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PFrame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PFrame, ULeapHand), 0x0040000000000000, Z_Construct_UClass_ULeapFrame_NoRegister());
				UProperty* NewProp_WristPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WristPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WristPosition, ULeapHand), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_TimeVisible = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TimeVisible"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeVisible, ULeapHand), 0x0010000000000015);
				UProperty* NewProp_StabilizedPalmPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StabilizedPalmPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(StabilizedPalmPosition, ULeapHand), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_SphereRadius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SphereRadius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(SphereRadius, ULeapHand), 0x0010000000000015);
				UProperty* NewProp_SphereCenter = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("SphereCenter"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(SphereCenter, ULeapHand), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_PinchStrength = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PinchStrength"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(PinchStrength, ULeapHand), 0x0010000000000015);
				UProperty* NewProp_PalmWidth = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PalmWidth"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(PalmWidth, ULeapHand), 0x0010000000000015);
				UProperty* NewProp_PalmVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PalmVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PalmVelocity, ULeapHand), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_PalmPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PalmPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PalmPosition, ULeapHand), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_PalmOrientation = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PalmOrientation"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PalmOrientation, ULeapHand), 0x0010000000000015, Z_Construct_UScriptStruct_FRotator());
				UProperty* NewProp_PalmNormal = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PalmNormal"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PalmNormal, ULeapHand), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsValid, ULeapHand, bool);
				UProperty* NewProp_IsValid = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsValid"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsValid, ULeapHand), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsValid, ULeapHand), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsRight, ULeapHand, bool);
				UProperty* NewProp_IsRight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsRight"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsRight, ULeapHand), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsRight, ULeapHand), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsLeft, ULeapHand, bool);
				UProperty* NewProp_IsLeft = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsLeft"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsLeft, ULeapHand), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsLeft, ULeapHand), sizeof(bool), true);
				UProperty* NewProp_Id = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Id"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Id, ULeapHand), 0x0010000000000015);
				UProperty* NewProp_HandType = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("HandType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(HandType, ULeapHand), 0x0010000000000015, Z_Construct_UEnum_LeapMotion_LeapHandType());
				UProperty* NewProp_GrabStrength = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GrabStrength"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(GrabStrength, ULeapHand), 0x0010000000000015);
				UProperty* NewProp_Direction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Direction"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Direction, ULeapHand), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Confidence = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Confidence"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Confidence, ULeapHand), 0x0010000000000015);
				UProperty* NewProp_Basis = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Basis"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Basis, ULeapHand), 0x0010000000000015, Z_Construct_UScriptStruct_FMatrix());
				UProperty* NewProp_Arm = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Arm"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Arm, ULeapHand), 0x0010000000000015, Z_Construct_UClass_ULeapArm_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapHand_Fingers(), "Fingers"); // 1021050446
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapHand_Frame(), "Frame"); // 1125112795
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapHand_RotationAngle(), "RotationAngle"); // 3882289014
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapHand_RotationAngleWithAxis(), "RotationAngleWithAxis"); // 156258613
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapHand_RotationAxis(), "RotationAxis"); // 2534254218
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapHand_RotationMatrix(), "RotationMatrix"); // 3578560511
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapHand_RotationProbability(), "RotationProbability"); // 1780154740
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapHand_ScaleFactor(), "ScaleFactor"); // 3594277266
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapHand_ScaleProbability(), "ScaleProbability"); // 1796015558
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapHand_Translation(), "Translation"); // 900847078
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapHand_TranslationProbability(), "TranslationProbability"); // 1265754765
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapHand.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The Hand class reports the physical characteristics of a detected hand.\nHand tracking data includes a palm position and velocity; vectors for\nthe palm normal and direction to the fingers; properties of a sphere\nfit to the hand; and lists of the attached fingers.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.Hand.html"));
				MetaData->SetValue(NewProp_PFingers, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_PFrame, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_WristPosition, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_WristPosition, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_WristPosition, TEXT("ToolTip"), TEXT("The position of the wrist of this hand."));
				MetaData->SetValue(NewProp_TimeVisible, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_TimeVisible, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_TimeVisible, TEXT("ToolTip"), TEXT("The duration of time this Hand has been visible to the Leap Motion Controller."));
				MetaData->SetValue(NewProp_StabilizedPalmPosition, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_StabilizedPalmPosition, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_StabilizedPalmPosition, TEXT("ToolTip"), TEXT("The stabilized palm position of this Hand."));
				MetaData->SetValue(NewProp_SphereRadius, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_SphereRadius, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_SphereRadius, TEXT("ToolTip"), TEXT("The radius of a sphere fit to the curvature of this hand. This sphere is placed roughly as\nif the hand were holding a ball."));
				MetaData->SetValue(NewProp_SphereCenter, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_SphereCenter, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_SphereCenter, TEXT("ToolTip"), TEXT("The center of a sphere fit to the curvature of this hand. This sphere is placed roughly as\nif the hand were holding a ball."));
				MetaData->SetValue(NewProp_PinchStrength, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_PinchStrength, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_PinchStrength, TEXT("ToolTip"), TEXT("The holding strength of a pinch hand pose. The strength is zero for an open hand,\nand blends to 1.0 when a pinching hand pose is recognized. Pinching can be done\nbetween the thumb and any other finger of the same hand."));
				MetaData->SetValue(NewProp_PalmWidth, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_PalmWidth, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_PalmWidth, TEXT("ToolTip"), TEXT("The estimated width of the palm when the hand is in a flat position."));
				MetaData->SetValue(NewProp_PalmVelocity, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_PalmVelocity, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_PalmVelocity, TEXT("ToolTip"), TEXT("The rate of change of the palm position in centimeters/second."));
				MetaData->SetValue(NewProp_PalmPosition, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_PalmPosition, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_PalmPosition, TEXT("ToolTip"), TEXT("The center position of the palm in centimeters from the Leap Motion Controller origin."));
				MetaData->SetValue(NewProp_PalmOrientation, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_PalmOrientation, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_PalmOrientation, TEXT("ToolTip"), TEXT("Custom API, Origin is a flat palm facing down."));
				MetaData->SetValue(NewProp_PalmNormal, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_PalmNormal, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_PalmNormal, TEXT("ToolTip"), TEXT("The normal vector to the palm. If your hand is flat, this vector will point downward,\nor ?out? of the front surface of your palm."));
				MetaData->SetValue(NewProp_IsValid, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_IsValid, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_IsValid, TEXT("ToolTip"), TEXT("Reports whether this is a valid Hand object."));
				MetaData->SetValue(NewProp_IsRight, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_IsRight, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_IsRight, TEXT("ToolTip"), TEXT("Whether this is a right hand."));
				MetaData->SetValue(NewProp_IsLeft, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_IsLeft, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_IsLeft, TEXT("ToolTip"), TEXT("Identifies whether this Hand is a left hand."));
				MetaData->SetValue(NewProp_Id, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_Id, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_Id, TEXT("ToolTip"), TEXT("* A unique ID assigned to this Hand object, whose value remains the same across consecutive\n* frames while the tracked hand remains visible."));
				MetaData->SetValue(NewProp_HandType, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_HandType, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_HandType, TEXT("ToolTip"), TEXT("Identifies whether this hand is Left, Right, or Unknown"));
				MetaData->SetValue(NewProp_GrabStrength, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_GrabStrength, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_GrabStrength, TEXT("ToolTip"), TEXT("The strength of a grab hand pose as a float value in the [0..1] range representing\nthe holding strength of the pose."));
				MetaData->SetValue(NewProp_Direction, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_Direction, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_Direction, TEXT("ToolTip"), TEXT("The direction from the palm position toward the fingers."));
				MetaData->SetValue(NewProp_Confidence, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_Confidence, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_Confidence, TEXT("ToolTip"), TEXT("How confident we are with a given hand pose.\nThe confidence level ranges between 0.0 and 1.0 inclusive."));
				MetaData->SetValue(NewProp_Basis, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_Basis, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_Basis, TEXT("ToolTip"), TEXT("The orientation of the hand as a basis matrix."));
				MetaData->SetValue(NewProp_Arm, TEXT("Category"), TEXT("Leap Hand"));
				MetaData->SetValue(NewProp_Arm, TEXT("ModuleRelativePath"), TEXT("Public/LeapHand.h"));
				MetaData->SetValue(NewProp_Arm, TEXT("ToolTip"), TEXT("The arm to which this hand is attached."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapHand(Z_Construct_UClass_ULeapHand, &ULeapHand::StaticClass, TEXT("ULeapHand"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapHand);
	UFunction* Z_Construct_UFunction_UAnimHand_ChangeBasis()
	{
		struct AnimHand_eventChangeBasis_Parms
		{
			FRotator PreBase;
			FRotator PostBase;
			bool AdjustVectors;
		};
		UObject* Outer=Z_Construct_UClass_UAnimHand();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ChangeBasis"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(AnimHand_eventChangeBasis_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(AdjustVectors, AnimHand_eventChangeBasis_Parms, bool);
			UProperty* NewProp_AdjustVectors = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AdjustVectors"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(AdjustVectors, AnimHand_eventChangeBasis_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(AdjustVectors, AnimHand_eventChangeBasis_Parms), sizeof(bool), true);
			UProperty* NewProp_PostBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PostBase"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PostBase, AnimHand_eventChangeBasis_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_PreBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PreBase"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PreBase, AnimHand_eventChangeBasis_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Hand"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_AdjustVectors"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimHand.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAnimHand_Enabled()
	{
		struct AnimHand_eventEnabled_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAnimHand();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Enabled"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AnimHand_eventEnabled_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AnimHand_eventEnabled_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AnimHand_eventEnabled_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AnimHand_eventEnabled_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Hand"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimHand.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAnimHand_SetEnabled()
	{
		struct AnimHand_eventSetEnabled_Parms
		{
			bool Enable;
		};
		UObject* Outer=Z_Construct_UClass_UAnimHand();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetEnabled"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AnimHand_eventSetEnabled_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(Enable, AnimHand_eventSetEnabled_Parms, bool);
			UProperty* NewProp_Enable = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Enable"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(Enable, AnimHand_eventSetEnabled_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(Enable, AnimHand_eventSetEnabled_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Hand"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_Enable"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimHand.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAnimHand_SetFromLeapHand()
	{
		struct AnimHand_eventSetFromLeapHand_Parms
		{
			ULeapHand* LeapHand;
		};
		UObject* Outer=Z_Construct_UClass_UAnimHand();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetFromLeapHand"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AnimHand_eventSetFromLeapHand_Parms));
			UProperty* NewProp_LeapHand = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("LeapHand"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(LeapHand, AnimHand_eventSetFromLeapHand_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapHand_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Hand"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimHand.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("These will turn into interface events for the general case later on"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAnimHand_TranslateHand()
	{
		struct AnimHand_eventTranslateHand_Parms
		{
			FVector Shift;
		};
		UObject* Outer=Z_Construct_UClass_UAnimHand();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TranslateHand"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(AnimHand_eventTranslateHand_Parms));
			UProperty* NewProp_Shift = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Shift"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Shift, AnimHand_eventTranslateHand_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Hand"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimHand.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAnimHand_NoRegister()
	{
		return UAnimHand::StaticClass();
	}
	UClass* Z_Construct_UClass_UAnimHand()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = UAnimHand::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20000080;

				OuterClass->LinkChild(Z_Construct_UFunction_UAnimHand_ChangeBasis());
				OuterClass->LinkChild(Z_Construct_UFunction_UAnimHand_Enabled());
				OuterClass->LinkChild(Z_Construct_UFunction_UAnimHand_SetEnabled());
				OuterClass->LinkChild(Z_Construct_UFunction_UAnimHand_SetFromLeapHand());
				OuterClass->LinkChild(Z_Construct_UFunction_UAnimHand_TranslateHand());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_LowerArm = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("LowerArm"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(LowerArm, UAnimHand), 0x0010000000000014, Z_Construct_UClass_UAnimBone_NoRegister());
				UProperty* NewProp_Palm = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Palm"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Palm, UAnimHand), 0x0010000000000014, Z_Construct_UClass_UAnimBone_NoRegister());
				UProperty* NewProp_Wrist = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Wrist"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Wrist, UAnimHand), 0x0010000000000014, Z_Construct_UClass_UAnimBone_NoRegister());
				UProperty* NewProp_Pinky = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Pinky"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Pinky, UAnimHand), 0x0010000000000014, Z_Construct_UClass_UAnimFinger_NoRegister());
				UProperty* NewProp_Ring = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Ring"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Ring, UAnimHand), 0x0010000000000014, Z_Construct_UClass_UAnimFinger_NoRegister());
				UProperty* NewProp_Middle = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Middle"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Middle, UAnimHand), 0x0010000000000014, Z_Construct_UClass_UAnimFinger_NoRegister());
				UProperty* NewProp_Index = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Index"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Index, UAnimHand), 0x0010000000000014, Z_Construct_UClass_UAnimFinger_NoRegister());
				UProperty* NewProp_Thumb = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Thumb"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Thumb, UAnimHand), 0x0010000000000014, Z_Construct_UClass_UAnimFinger_NoRegister());
				UProperty* NewProp_Confidence = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Confidence"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Confidence, UAnimHand), 0x0010000000000014);
				UProperty* NewProp_Alpha = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Alpha"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Alpha, UAnimHand), 0x0010000000000015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimHand_ChangeBasis(), "ChangeBasis"); // 1548293092
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimHand_Enabled(), "Enabled"); // 770681045
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimHand_SetEnabled(), "SetEnabled"); // 3864494565
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimHand_SetFromLeapHand(), "SetFromLeapHand"); // 418067602
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimHand_TranslateHand(), "TranslateHand"); // 293503688
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("AnimBody/AnimHand.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimHand.h"));
				MetaData->SetValue(NewProp_LowerArm, TEXT("Category"), TEXT("Anim Hand"));
				MetaData->SetValue(NewProp_LowerArm, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimHand.h"));
				MetaData->SetValue(NewProp_Palm, TEXT("Category"), TEXT("Anim Hand"));
				MetaData->SetValue(NewProp_Palm, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimHand.h"));
				MetaData->SetValue(NewProp_Wrist, TEXT("Category"), TEXT("Anim Hand"));
				MetaData->SetValue(NewProp_Wrist, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimHand.h"));
				MetaData->SetValue(NewProp_Wrist, TEXT("ToolTip"), TEXT("Arm and Wrist, NB: Consider moving this up the skeletal tree, for leap this is sufficient"));
				MetaData->SetValue(NewProp_Pinky, TEXT("Category"), TEXT("Anim Hand Finger"));
				MetaData->SetValue(NewProp_Pinky, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimHand.h"));
				MetaData->SetValue(NewProp_Ring, TEXT("Category"), TEXT("Anim Hand Finger"));
				MetaData->SetValue(NewProp_Ring, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimHand.h"));
				MetaData->SetValue(NewProp_Middle, TEXT("Category"), TEXT("Anim Hand Finger"));
				MetaData->SetValue(NewProp_Middle, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimHand.h"));
				MetaData->SetValue(NewProp_Index, TEXT("Category"), TEXT("Anim Hand Finger"));
				MetaData->SetValue(NewProp_Index, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimHand.h"));
				MetaData->SetValue(NewProp_Thumb, TEXT("Category"), TEXT("Anim Hand Finger"));
				MetaData->SetValue(NewProp_Thumb, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimHand.h"));
				MetaData->SetValue(NewProp_Thumb, TEXT("ToolTip"), TEXT("Fingers"));
				MetaData->SetValue(NewProp_Confidence, TEXT("Category"), TEXT("Anim Hand Hand"));
				MetaData->SetValue(NewProp_Confidence, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimHand.h"));
				MetaData->SetValue(NewProp_Alpha, TEXT("Category"), TEXT("Anim Hand"));
				MetaData->SetValue(NewProp_Alpha, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimHand.h"));
				MetaData->SetValue(NewProp_Alpha, TEXT("ToolTip"), TEXT("Hand Properties"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAnimHand(Z_Construct_UClass_UAnimHand, &UAnimHand::StaticClass, TEXT("UAnimHand"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAnimHand);
	UFunction* Z_Construct_UFunction_UAnimBody_ChangeBasis()
	{
		struct AnimBody_eventChangeBasis_Parms
		{
			FRotator PreBase;
			FRotator PostBase;
			bool AdjustVectors;
		};
		UObject* Outer=Z_Construct_UClass_UAnimBody();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ChangeBasis"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(AnimBody_eventChangeBasis_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(AdjustVectors, AnimBody_eventChangeBasis_Parms, bool);
			UProperty* NewProp_AdjustVectors = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AdjustVectors"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(AdjustVectors, AnimBody_eventChangeBasis_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(AdjustVectors, AnimBody_eventChangeBasis_Parms), sizeof(bool), true);
			UProperty* NewProp_PostBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PostBase"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PostBase, AnimBody_eventChangeBasis_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_PreBase = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("PreBase"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PreBase, AnimBody_eventChangeBasis_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FRotator());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Body"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_AdjustVectors"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBody.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAnimBody_Enabled()
	{
		struct AnimBody_eventEnabled_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_UAnimBody();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Enabled"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AnimBody_eventEnabled_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, AnimBody_eventEnabled_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, AnimBody_eventEnabled_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, AnimBody_eventEnabled_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Body"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBody.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAnimBody_SetEnabled()
	{
		struct AnimBody_eventSetEnabled_Parms
		{
			bool Enable;
		};
		UObject* Outer=Z_Construct_UClass_UAnimBody();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetEnabled"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(AnimBody_eventSetEnabled_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(Enable, AnimBody_eventSetEnabled_Parms, bool);
			UProperty* NewProp_Enable = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Enable"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(Enable, AnimBody_eventSetEnabled_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(Enable, AnimBody_eventSetEnabled_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Body"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_Enable"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBody.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UAnimBody_TranslateBody()
	{
		struct AnimBody_eventTranslateBody_Parms
		{
			FVector Shift;
		};
		UObject* Outer=Z_Construct_UClass_UAnimBody();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TranslateBody"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(AnimBody_eventTranslateBody_Parms));
			UProperty* NewProp_Shift = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Shift"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Shift, AnimBody_eventTranslateBody_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Anim Body"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBody.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UAnimBody_NoRegister()
	{
		return UAnimBody::StaticClass();
	}
	UClass* Z_Construct_UClass_UAnimBody()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = UAnimBody::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20A00080;

				OuterClass->LinkChild(Z_Construct_UFunction_UAnimBody_ChangeBasis());
				OuterClass->LinkChild(Z_Construct_UFunction_UAnimBody_Enabled());
				OuterClass->LinkChild(Z_Construct_UFunction_UAnimBody_SetEnabled());
				OuterClass->LinkChild(Z_Construct_UFunction_UAnimBody_TranslateBody());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Head = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Head"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Head, UAnimBody), 0x0010000000000014, Z_Construct_UClass_UAnimBone_NoRegister());
				UProperty* NewProp_Right = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Right"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Right, UAnimBody), 0x0010000000000014, Z_Construct_UClass_UAnimHand_NoRegister());
				UProperty* NewProp_Left = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Left"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Left, UAnimBody), 0x0010000000000014, Z_Construct_UClass_UAnimHand_NoRegister());
				UProperty* NewProp_Alpha = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Alpha"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Alpha, UAnimBody), 0x0010000000000004);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimBody_ChangeBasis(), "ChangeBasis"); // 1482094180
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimBody_Enabled(), "Enabled"); // 561312006
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimBody_SetEnabled(), "SetEnabled"); // 2124954221
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_UAnimBody_TranslateBody(), "TranslateBody"); // 1589235804
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Animation Skeleton"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("AnimBody/AnimBody.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBody.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("NB: this is a limited class used only for leap anim, full class will have full body"));
				MetaData->SetValue(NewProp_Head, TEXT("Category"), TEXT("Anim Body"));
				MetaData->SetValue(NewProp_Head, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBody.h"));
				MetaData->SetValue(NewProp_Head, TEXT("ToolTip"), TEXT("Head"));
				MetaData->SetValue(NewProp_Right, TEXT("Category"), TEXT("Anim Body"));
				MetaData->SetValue(NewProp_Right, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBody.h"));
				MetaData->SetValue(NewProp_Left, TEXT("Category"), TEXT("Anim Body"));
				MetaData->SetValue(NewProp_Left, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBody.h"));
				MetaData->SetValue(NewProp_Left, TEXT("ToolTip"), TEXT("Hands"));
				MetaData->SetValue(NewProp_Alpha, TEXT("Category"), TEXT("Anim Body"));
				MetaData->SetValue(NewProp_Alpha, TEXT("ModuleRelativePath"), TEXT("Public/AnimBody/AnimBody.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UAnimBody(Z_Construct_UClass_UAnimBody, &UAnimBody::StaticClass, TEXT("UAnimBody"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(UAnimBody);
	UFunction* Z_Construct_UFunction_ULeapArm_GetOrientation()
	{
		struct LeapArm_eventGetOrientation_Parms
		{
			TEnumAsByte<LeapHandType> handType;
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapArm();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetOrientation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(LeapArm_eventGetOrientation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, LeapArm_eventGetOrientation_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_handType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("handType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(handType, LeapArm_eventGetOrientation_Parms), 0x0010000000000080, Z_Construct_UEnum_LeapMotion_LeapHandType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Arm"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapArm.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Basis matrix in rotation form for the arm given the hand\n@param HandType left or right\n@return Orientation basis"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapArm_NoRegister()
	{
		return ULeapArm::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapArm()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapArm::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapArm_GetOrientation());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_WristPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("WristPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(WristPosition, ULeapArm), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Width = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Width"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Width, ULeapArm), 0x0010000000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsValid, ULeapArm, bool);
				UProperty* NewProp_IsValid = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsValid"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsValid, ULeapArm), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsValid, ULeapArm), sizeof(bool), true);
				UProperty* NewProp_ElbowPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ElbowPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ElbowPosition, ULeapArm), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Direction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Direction"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Direction, ULeapArm), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Center = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Center"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Center, ULeapArm), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Basis = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Basis"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Basis, ULeapArm), 0x0010000000000015, Z_Construct_UScriptStruct_FMatrix());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapArm_GetOrientation(), "GetOrientation"); // 283203894
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapArm.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapArm.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The Arm class represents the forearm.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.Arm.html"));
				MetaData->SetValue(NewProp_WristPosition, TEXT("Category"), TEXT("Leap Arm"));
				MetaData->SetValue(NewProp_WristPosition, TEXT("ModuleRelativePath"), TEXT("Public/LeapArm.h"));
				MetaData->SetValue(NewProp_WristPosition, TEXT("ToolTip"), TEXT("The position of the wrist of this hand.\n@return A vector containing the coordinates of the wrist position in centimeters."));
				MetaData->SetValue(NewProp_Width, TEXT("Category"), TEXT("Leap Arm"));
				MetaData->SetValue(NewProp_Width, TEXT("ModuleRelativePath"), TEXT("Public/LeapArm.h"));
				MetaData->SetValue(NewProp_Width, TEXT("ToolTip"), TEXT("The estimated width of the palm when the hand is in a flat position.\n@return Width"));
				MetaData->SetValue(NewProp_IsValid, TEXT("Category"), TEXT("Leap Arm"));
				MetaData->SetValue(NewProp_IsValid, TEXT("ModuleRelativePath"), TEXT("Public/LeapArm.h"));
				MetaData->SetValue(NewProp_IsValid, TEXT("ToolTip"), TEXT("Reports whether this is a valid Hand object.\n@return True, if this Hand object contains valid tracking data."));
				MetaData->SetValue(NewProp_ElbowPosition, TEXT("Category"), TEXT("Leap Arm"));
				MetaData->SetValue(NewProp_ElbowPosition, TEXT("ModuleRelativePath"), TEXT("Public/LeapArm.h"));
				MetaData->SetValue(NewProp_ElbowPosition, TEXT("ToolTip"), TEXT("The position of the elbow."));
				MetaData->SetValue(NewProp_Direction, TEXT("Category"), TEXT("Leap Arm"));
				MetaData->SetValue(NewProp_Direction, TEXT("ModuleRelativePath"), TEXT("Public/LeapArm.h"));
				MetaData->SetValue(NewProp_Direction, TEXT("ToolTip"), TEXT("The normalized direction in which the arm is pointing (from elbow to wrist)."));
				MetaData->SetValue(NewProp_Center, TEXT("Category"), TEXT("Leap Arm"));
				MetaData->SetValue(NewProp_Center, TEXT("ModuleRelativePath"), TEXT("Public/LeapArm.h"));
				MetaData->SetValue(NewProp_Center, TEXT("ToolTip"), TEXT("The center of the forearm."));
				MetaData->SetValue(NewProp_Basis, TEXT("Category"), TEXT("Leap Arm"));
				MetaData->SetValue(NewProp_Basis, TEXT("ModuleRelativePath"), TEXT("Public/LeapArm.h"));
				MetaData->SetValue(NewProp_Basis, TEXT("ToolTip"), TEXT("The orthonormal basis vectors for the Arm bone as a Matrix."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapArm(Z_Construct_UClass_ULeapArm, &ULeapArm::StaticClass, TEXT("ULeapArm"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapArm);
	UClass* Z_Construct_UClass_ULeapBaseObject_NoRegister()
	{
		return ULeapBaseObject::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapBaseObject()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapBaseObject::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapBaseObject.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapBaseObject.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Optional base class for custom memory management"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapBaseObject(Z_Construct_UClass_ULeapBaseObject, &ULeapBaseObject::StaticClass, TEXT("ULeapBaseObject"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapBaseObject);
	UFunction* Z_Construct_UFunction_ULeapBone_Different()
	{
		struct LeapBone_eventDifferent_Parms
		{
			const ULeapBone* other;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapBone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Different"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(LeapBone_eventDifferent_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapBone_eventDifferent_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapBone_eventDifferent_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapBone_eventDifferent_Parms), sizeof(bool), true);
			UProperty* NewProp_other = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("other"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(other, LeapBone_eventDifferent_Parms), 0x0010000000000082, Z_Construct_UClass_ULeapBone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Bone"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT("!="));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("different"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("different operator"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapBone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Compare Bone object inequality.\n\n@return False if and only if both Bone objects represent the exact same physical bone in the same frame and both Bone objects are valid."));
			MetaData->SetValue(NewProp_other, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapBone_Equal()
	{
		struct LeapBone_eventEqual_Parms
		{
			const ULeapBone* other;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapBone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Equal"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(LeapBone_eventEqual_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapBone_eventEqual_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapBone_eventEqual_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapBone_eventEqual_Parms), sizeof(bool), true);
			UProperty* NewProp_other = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("other"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(other, LeapBone_eventEqual_Parms), 0x0010000000000082, Z_Construct_UClass_ULeapBone_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Bone"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT("=="));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("equal"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("equal operator"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapBone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Compare Bone object equality.\n\n@return True if and only if both Bone objects represent the exact same physical bone in the same frame and both Bone objects are valid."));
			MetaData->SetValue(NewProp_other, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapBone_GetOrientation()
	{
		struct LeapBone_eventGetOrientation_Parms
		{
			TEnumAsByte<LeapHandType> handType;
			FRotator ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapBone();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetOrientation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(LeapBone_eventGetOrientation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, LeapBone_eventGetOrientation_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FRotator());
			UProperty* NewProp_handType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("handType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(handType, LeapBone_eventGetOrientation_Parms), 0x0010000000000080, Z_Construct_UEnum_LeapMotion_LeapHandType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Bone"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapBone.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Convenience method, requires knowledge of the hand this bone belongs to in order to\ngive a correct orientation (left hand basis is different from right).\n\n@param HandType left or right"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapBone_NoRegister()
	{
		return ULeapBone::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapBone()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapBone::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapBone_Different());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapBone_Equal());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapBone_GetOrientation());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Width = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Width"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Width, ULeapBone), 0x0010000000000015);
				UProperty* NewProp_Type = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Type"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Type, ULeapBone), 0x0010000000000015, Z_Construct_UEnum_LeapMotion_LeapBoneType());
				UProperty* NewProp_PrevJoint = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PrevJoint"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(PrevJoint, ULeapBone), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_NextJoint = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("NextJoint"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(NextJoint, ULeapBone), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Length = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Length"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Length, ULeapBone), 0x0010000000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsValid, ULeapBone, bool);
				UProperty* NewProp_IsValid = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsValid"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsValid, ULeapBone), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsValid, ULeapBone), sizeof(bool), true);
				UProperty* NewProp_Direction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Direction"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Direction, ULeapBone), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Center = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Center"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Center, ULeapBone), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Basis = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Basis"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Basis, ULeapBone), 0x0010000000000015, Z_Construct_UScriptStruct_FMatrix());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapBone_Different(), "Different"); // 980078835
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapBone_Equal(), "Equal"); // 1408482424
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapBone_GetOrientation(), "GetOrientation"); // 1793631786
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapBone.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapBone.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The Bone class represents a tracked bone.\nAll fingers contain 4 bones that make up the anatomy of the finger.\nGet valid Bone objects from a Finger object.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.Bone.html"));
				MetaData->SetValue(NewProp_Width, TEXT("Category"), TEXT("Leap Bone"));
				MetaData->SetValue(NewProp_Width, TEXT("ModuleRelativePath"), TEXT("Public/LeapBone.h"));
				MetaData->SetValue(NewProp_Width, TEXT("ToolTip"), TEXT("The average width of the flesh around the bone in centimeters."));
				MetaData->SetValue(NewProp_Type, TEXT("Category"), TEXT("Leap Bone"));
				MetaData->SetValue(NewProp_Type, TEXT("ModuleRelativePath"), TEXT("Public/LeapBone.h"));
				MetaData->SetValue(NewProp_Type, TEXT("ToolTip"), TEXT("The name of this bone."));
				MetaData->SetValue(NewProp_PrevJoint, TEXT("Category"), TEXT("Leap Bone"));
				MetaData->SetValue(NewProp_PrevJoint, TEXT("ModuleRelativePath"), TEXT("Public/LeapBone.h"));
				MetaData->SetValue(NewProp_PrevJoint, TEXT("ToolTip"), TEXT("The base of the bone, closest to the wrist.\nIn anatomical terms, this is the proximal end of the bone."));
				MetaData->SetValue(NewProp_NextJoint, TEXT("Category"), TEXT("Leap Bone"));
				MetaData->SetValue(NewProp_NextJoint, TEXT("ModuleRelativePath"), TEXT("Public/LeapBone.h"));
				MetaData->SetValue(NewProp_NextJoint, TEXT("ToolTip"), TEXT("The end of the bone, closest to the finger tip.\nIn anatomical terms, this is the distal end of the bone."));
				MetaData->SetValue(NewProp_Length, TEXT("Category"), TEXT("Leap Bone"));
				MetaData->SetValue(NewProp_Length, TEXT("ModuleRelativePath"), TEXT("Public/LeapBone.h"));
				MetaData->SetValue(NewProp_Length, TEXT("ToolTip"), TEXT("The estimated length of the bone in centimeters."));
				MetaData->SetValue(NewProp_IsValid, TEXT("Category"), TEXT("Leap Bone"));
				MetaData->SetValue(NewProp_IsValid, TEXT("ModuleRelativePath"), TEXT("Public/LeapBone.h"));
				MetaData->SetValue(NewProp_IsValid, TEXT("ToolTip"), TEXT("Reports whether this is a valid Bone object.\n@return True, if this Bone object contains valid tracking data."));
				MetaData->SetValue(NewProp_Direction, TEXT("Category"), TEXT("Leap Bone"));
				MetaData->SetValue(NewProp_Direction, TEXT("ModuleRelativePath"), TEXT("Public/LeapBone.h"));
				MetaData->SetValue(NewProp_Direction, TEXT("ToolTip"), TEXT("The normalized direction of the bone from base to tip."));
				MetaData->SetValue(NewProp_Center, TEXT("Category"), TEXT("Leap Bone"));
				MetaData->SetValue(NewProp_Center, TEXT("ModuleRelativePath"), TEXT("Public/LeapBone.h"));
				MetaData->SetValue(NewProp_Center, TEXT("ToolTip"), TEXT("The midpoint of the bone."));
				MetaData->SetValue(NewProp_Basis, TEXT("Category"), TEXT("Leap Bone"));
				MetaData->SetValue(NewProp_Basis, TEXT("ModuleRelativePath"), TEXT("Public/LeapBone.h"));
				MetaData->SetValue(NewProp_Basis, TEXT("ToolTip"), TEXT("The orthonormal basis vectors for this Bone as a Matrix."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapBone(Z_Construct_UClass_ULeapBone, &ULeapBone::StaticClass, TEXT("ULeapBone"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapBone);
	UFunction* Z_Construct_UFunction_ULeapGesture_Frame()
	{
		struct LeapGesture_eventFrame_Parms
		{
			ULeapFrame* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapGesture();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Frame"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapGesture_eventFrame_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapGesture_eventFrame_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Gesture"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("frame"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapGesture.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The Frame containing this Gesture instance.\n\n@return The parent Frame object."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapGesture_Hands()
	{
		struct LeapGesture_eventHands_Parms
		{
			ULeapHandList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapGesture();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Hands"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapGesture_eventHands_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapGesture_eventHands_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapHandList_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Gesture"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("hands"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("hands"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapGesture.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The list of hands associated with this Gesture, if any.\n\n@return the list of related Hand objects."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapGesture_Pointables()
	{
		struct LeapGesture_eventPointables_Parms
		{
			ULeapPointableList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapGesture();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Pointables"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapGesture_eventPointables_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapGesture_eventPointables_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapPointableList_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Gesture"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("pointables"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("pointables"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapGesture.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The list of fingers and tools associated with this Gesture, if any.\n\n@return the list of related Pointable objects."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapGesture_NoRegister()
	{
		return ULeapGesture::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapGesture()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapGesture::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapGesture_Frame());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapGesture_Hands());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapGesture_Pointables());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PPointables = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PPointables"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PPointables, ULeapGesture), 0x0040000000000000, Z_Construct_UClass_ULeapPointableList_NoRegister());
				UProperty* NewProp_PHands = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PHands"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PHands, ULeapGesture), 0x0040000000000000, Z_Construct_UClass_ULeapHandList_NoRegister());
				UProperty* NewProp_PFrame = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PFrame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PFrame, ULeapGesture), 0x0040000000000000, Z_Construct_UClass_ULeapFrame_NoRegister());
				UProperty* NewProp_Type = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Type"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Type, ULeapGesture), 0x0010000000000015, Z_Construct_UEnum_LeapMotion_LeapGestureType());
				UProperty* NewProp_State = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("State"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(State, ULeapGesture), 0x0010000000000015, Z_Construct_UEnum_LeapMotion_LeapGestureState());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsValid, ULeapGesture, bool);
				UProperty* NewProp_IsValid = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsValid"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsValid, ULeapGesture), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsValid, ULeapGesture), sizeof(bool), true);
				UProperty* NewProp_Id = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Id"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Id, ULeapGesture), 0x0010000000000015);
				UProperty* NewProp_DurationSeconds = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DurationSeconds"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(DurationSeconds, ULeapGesture), 0x0010000000000015);
				UProperty* NewProp_Duration = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Duration"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Duration, ULeapGesture), 0x0010000000000015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapGesture_Frame(), "Frame"); // 2970674922
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapGesture_Hands(), "Hands"); // 332926145
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapGesture_Pointables(), "Pointables"); // 301010271
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapGesture.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapGesture.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The Gesture class represents a recognized movement by the user.\nThe Leap Motion Controller watches the activity within its field of view for certain\nmovement patterns typical of a user gesture or command. For example, a movement from\nside to side with the hand can indicate a swipe gesture, while a finger poking forward\ncan indicate a screen tap gesture.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.Gesture.html"));
				MetaData->SetValue(NewProp_PPointables, TEXT("ModuleRelativePath"), TEXT("Public/LeapGesture.h"));
				MetaData->SetValue(NewProp_PHands, TEXT("ModuleRelativePath"), TEXT("Public/LeapGesture.h"));
				MetaData->SetValue(NewProp_PFrame, TEXT("ModuleRelativePath"), TEXT("Public/LeapGesture.h"));
				MetaData->SetValue(NewProp_Type, TEXT("Category"), TEXT("Leap Gesture"));
				MetaData->SetValue(NewProp_Type, TEXT("ModuleRelativePath"), TEXT("Public/LeapGesture.h"));
				MetaData->SetValue(NewProp_Type, TEXT("ToolTip"), TEXT("The gesture type."));
				MetaData->SetValue(NewProp_State, TEXT("Category"), TEXT("Leap Gesture"));
				MetaData->SetValue(NewProp_State, TEXT("ModuleRelativePath"), TEXT("Public/LeapGesture.h"));
				MetaData->SetValue(NewProp_State, TEXT("ToolTip"), TEXT("The gesture state.\nRecognized movements occur over time and have a beginning, a middle, and an end.\nThe ?state? attribute reports where in that sequence this Gesture object falls."));
				MetaData->SetValue(NewProp_IsValid, TEXT("Category"), TEXT("Leap Gesture"));
				MetaData->SetValue(NewProp_IsValid, TEXT("ModuleRelativePath"), TEXT("Public/LeapGesture.h"));
				MetaData->SetValue(NewProp_IsValid, TEXT("ToolTip"), TEXT("Reports whether this Gesture instance represents a valid Gesture."));
				MetaData->SetValue(NewProp_Id, TEXT("Category"), TEXT("Leap Gesture"));
				MetaData->SetValue(NewProp_Id, TEXT("ModuleRelativePath"), TEXT("Public/LeapGesture.h"));
				MetaData->SetValue(NewProp_Id, TEXT("ToolTip"), TEXT("The gesture ID."));
				MetaData->SetValue(NewProp_DurationSeconds, TEXT("Category"), TEXT("Leap Gesture"));
				MetaData->SetValue(NewProp_DurationSeconds, TEXT("ModuleRelativePath"), TEXT("Public/LeapGesture.h"));
				MetaData->SetValue(NewProp_DurationSeconds, TEXT("ToolTip"), TEXT("The elapsed duration in seconds."));
				MetaData->SetValue(NewProp_Duration, TEXT("Category"), TEXT("Leap Gesture"));
				MetaData->SetValue(NewProp_Duration, TEXT("ModuleRelativePath"), TEXT("Public/LeapGesture.h"));
				MetaData->SetValue(NewProp_Duration, TEXT("ToolTip"), TEXT("The elapsed duration of the recognized movement up to the frame containing this\nGesture object, in microseconds."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapGesture(Z_Construct_UClass_ULeapGesture, &ULeapGesture::StaticClass, TEXT("ULeapGesture"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapGesture);
	UFunction* Z_Construct_UFunction_ULeapController_EnableBackgroundTracking()
	{
		struct LeapController_eventEnableBackgroundTracking_Parms
		{
			bool TrackInBackground;
		};
		UObject* Outer=Z_Construct_UClass_ULeapController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EnableBackgroundTracking"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapController_eventEnableBackgroundTracking_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(TrackInBackground, LeapController_eventEnableBackgroundTracking_Parms, bool);
			UProperty* NewProp_TrackInBackground = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TrackInBackground"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(TrackInBackground, LeapController_eventEnableBackgroundTracking_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(TrackInBackground, LeapController_eventEnableBackgroundTracking_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Controller"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_TrackInBackground"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("enable background tracking"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Requests that your application receives frames when it is not the foreground application for user input.\n\n@param TrackInBackground toggle to enable or disable"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapController_EnableGesture()
	{
		struct LeapController_eventEnableGesture_Parms
		{
			TEnumAsByte<LeapGestureType> GestureType;
			bool Enable;
		};
		UObject* Outer=Z_Construct_UClass_ULeapController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EnableGesture"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapController_eventEnableGesture_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(Enable, LeapController_eventEnableGesture_Parms, bool);
			UProperty* NewProp_Enable = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Enable"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(Enable, LeapController_eventEnableGesture_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(Enable, LeapController_eventEnableGesture_Parms), sizeof(bool), true);
			UProperty* NewProp_GestureType = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("GestureType"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(GestureType, LeapController_eventEnableGesture_Parms), 0x0010000000000080, Z_Construct_UEnum_LeapMotion_LeapGestureType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Controller"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_Enable"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("enable gesture"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Enables or disables reporting of a specified gesture type.\n\n@param GestureType category of gesture you wish to enable or disable\n@param Enable whether the gesture detection should be enabled"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapController_EnableImageSupport()
	{
		struct LeapController_eventEnableImageSupport_Parms
		{
			bool AllowImages;
			bool EmitImageEvents;
			bool UseGammaCorrection;
		};
		UObject* Outer=Z_Construct_UClass_ULeapController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("EnableImageSupport"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapController_eventEnableImageSupport_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(UseGammaCorrection, LeapController_eventEnableImageSupport_Parms, bool);
			UProperty* NewProp_UseGammaCorrection = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("UseGammaCorrection"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(UseGammaCorrection, LeapController_eventEnableImageSupport_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(UseGammaCorrection, LeapController_eventEnableImageSupport_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(EmitImageEvents, LeapController_eventEnableImageSupport_Parms, bool);
			UProperty* NewProp_EmitImageEvents = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("EmitImageEvents"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(EmitImageEvents, LeapController_eventEnableImageSupport_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(EmitImageEvents, LeapController_eventEnableImageSupport_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(AllowImages, LeapController_eventEnableImageSupport_Parms, bool);
			UProperty* NewProp_AllowImages = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AllowImages"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(AllowImages, LeapController_eventEnableImageSupport_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(AllowImages, LeapController_eventEnableImageSupport_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Controller"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_AllowImages"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_EmitImageEvents"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_UseGammaCorrection"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("use allow images set policy"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Enable image streaming by the leap motion. Optionally emit raw image events and adjust images by standard gamma correction.\n\n@param AllowImages enable image support at minimum for polling\n@param EmitImageEvents whether to emit raw image event whenever they're ready\n@param UseGammaCorrection true if you wish to use image gamma correction"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapController_Frame()
	{
		struct LeapController_eventFrame_Parms
		{
			int32 History;
			ULeapFrame* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Frame"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapController_eventFrame_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapController_eventFrame_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapFrame_NoRegister());
			UProperty* NewProp_History = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("History"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(History, LeapController_eventFrame_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Controller"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Get Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns a frame of tracking data from the Leap Motion software.\nCall frame() or frame(0) to access the most recent frame; call frame(1)\nto access the previous frame, and so on. If you use a history value greater\nthan the number of stored frames, then the controller returns an invalid frame.\n\n@param optional history parameter to specify which frame to retrieve.\n@return The specified frame; or, if no history parameter is specified, the newest frame. If a frame is not available at the specified history position, an invalid Frame is returned."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapController_HasFocus()
	{
		struct LeapController_eventHasFocus_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("HasFocus"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(LeapController_eventHasFocus_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapController_eventHasFocus_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapController_eventHasFocus_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapController_eventHasFocus_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Controller"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("has Focus"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Reports whether this application is the focused, foreground application.\n\n@return True, if application has focus; false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapController_IsConnected()
	{
		struct LeapController_eventIsConnected_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsConnected"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(LeapController_eventIsConnected_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapController_eventIsConnected_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapController_eventIsConnected_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapController_eventIsConnected_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Controller"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("is connected"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Reports whether this Controller is connected to the Leap Motion service and the Leap Motion hardware is plugged in."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapController_IsServiceConnected()
	{
		struct LeapController_eventIsServiceConnected_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsServiceConnected"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(LeapController_eventIsServiceConnected_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapController_eventIsServiceConnected_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapController_eventIsServiceConnected_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapController_eventIsServiceConnected_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Controller"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("is service connected"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Reports whether this Controller is connected to the Leap Motion service and the Leap Motion hardware is plugged in.\n\n@return True, if connected; false otherwise."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapController_OptimizeForHMD()
	{
		struct LeapController_eventOptimizeForHMD_Parms
		{
			bool UseTopdown;
			bool AutoRotate;
			bool AutoShift;
		};
		UObject* Outer=Z_Construct_UClass_ULeapController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OptimizeForHMD"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapController_eventOptimizeForHMD_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(AutoShift, LeapController_eventOptimizeForHMD_Parms, bool);
			UProperty* NewProp_AutoShift = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AutoShift"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(AutoShift, LeapController_eventOptimizeForHMD_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(AutoShift, LeapController_eventOptimizeForHMD_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(AutoRotate, LeapController_eventOptimizeForHMD_Parms, bool);
			UProperty* NewProp_AutoRotate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("AutoRotate"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(AutoRotate, LeapController_eventOptimizeForHMD_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(AutoRotate, LeapController_eventOptimizeForHMD_Parms), sizeof(bool), true);
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(UseTopdown, LeapController_eventOptimizeForHMD_Parms, bool);
			UProperty* NewProp_UseTopdown = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("UseTopdown"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(UseTopdown, LeapController_eventOptimizeForHMD_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(UseTopdown, LeapController_eventOptimizeForHMD_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Controller"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_AutoRotate"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_AutoShift"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_UseTopdown"), TEXT("false"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("optimize hmd facing top set policy"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Set Flags and tracking for the plugin to use tracking expecting leap mounted on HMD.\nOptionally auto-rotate and auto-shift values by the movement of the hmd (useful pre-4.11)"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapController_SetInterfaceDelegate()
	{
		struct LeapController_eventSetInterfaceDelegate_Parms
		{
			UObject* NewDelegate;
		};
		UObject* Outer=Z_Construct_UClass_ULeapController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetInterfaceDelegate"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapController_eventSetInterfaceDelegate_Parms));
			UProperty* NewProp_NewDelegate = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NewDelegate"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(NewDelegate, LeapController_eventSetInterfaceDelegate_Parms), 0x0010000000000080, Z_Construct_UClass_UObject_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("set delegate self"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Leap Event Interface forwarding, automatically set since 0.6.2, available for event redirection"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapController_SetLeapMountToHMDOffset()
	{
		struct LeapController_eventSetLeapMountToHMDOffset_Parms
		{
			FVector Offset;
		};
		UObject* Outer=Z_Construct_UClass_ULeapController();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SetLeapMountToHMDOffset"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(LeapController_eventSetLeapMountToHMDOffset_Parms));
			UProperty* NewProp_Offset = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Offset"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Offset, LeapController_eventSetLeapMountToHMDOffset_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Controller"));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_Offset"), TEXT("8.000000,0.000000,0.000000"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Specify a custom leap to eye offset. Given in UE coordinate system (XForward).\n\n@param Offset offset vector, defaults to DK2 value (8cm forward)"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapController_NoRegister()
	{
		return ULeapController::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapController()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UActorComponent();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapController::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20B00080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapController_EnableBackgroundTracking());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapController_EnableGesture());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapController_EnableImageSupport());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapController_Frame());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapController_HasFocus());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapController_IsConnected());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapController_IsServiceConnected());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapController_OptimizeForHMD());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapController_SetInterfaceDelegate());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapController_SetLeapMountToHMDOffset());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PEventImage2 = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PEventImage2"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PEventImage2, ULeapController), 0x0040000000000000, Z_Construct_UClass_ULeapImage_NoRegister());
				UProperty* NewProp_PEventImage1 = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PEventImage1"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PEventImage1, ULeapController), 0x0040000000000000, Z_Construct_UClass_ULeapImage_NoRegister());
				UProperty* NewProp_PEventSwipeGesture = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PEventSwipeGesture"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PEventSwipeGesture, ULeapController), 0x0040000000000000, Z_Construct_UClass_ULeapSwipeGesture_NoRegister());
				UProperty* NewProp_PEventScreenTapGesture = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PEventScreenTapGesture"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PEventScreenTapGesture, ULeapController), 0x0040000000000000, Z_Construct_UClass_ULeapScreenTapGesture_NoRegister());
				UProperty* NewProp_PEventKeyTapGesture = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PEventKeyTapGesture"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PEventKeyTapGesture, ULeapController), 0x0040000000000000, Z_Construct_UClass_ULeapKeyTapGesture_NoRegister());
				UProperty* NewProp_PEventCircleGesture = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PEventCircleGesture"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PEventCircleGesture, ULeapController), 0x0040000000000000, Z_Construct_UClass_ULeapCircleGesture_NoRegister());
				UProperty* NewProp_PEventGesture = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PEventGesture"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PEventGesture, ULeapController), 0x0040000000000000, Z_Construct_UClass_ULeapGesture_NoRegister());
				UProperty* NewProp_PEventFinger = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PEventFinger"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PEventFinger, ULeapController), 0x0040000000000000, Z_Construct_UClass_ULeapFinger_NoRegister());
				UProperty* NewProp_PEventHand = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PEventHand"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PEventHand, ULeapController), 0x0040000000000000, Z_Construct_UClass_ULeapHand_NoRegister());
				UProperty* NewProp_PFrame = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PFrame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PFrame, ULeapController), 0x0040000000000000, Z_Construct_UClass_ULeapFrame_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapController_EnableBackgroundTracking(), "EnableBackgroundTracking"); // 292375335
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapController_EnableGesture(), "EnableGesture"); // 1063366642
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapController_EnableImageSupport(), "EnableImageSupport"); // 3332617860
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapController_Frame(), "Frame"); // 526550122
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapController_HasFocus(), "HasFocus"); // 999897560
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapController_IsConnected(), "IsConnected"); // 2616465799
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapController_IsServiceConnected(), "IsServiceConnected"); // 2156310172
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapController_OptimizeForHMD(), "OptimizeForHMD"); // 1963788797
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapController_SetInterfaceDelegate(), "SetInterfaceDelegate"); // 3295681293
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapController_SetLeapMountToHMDOffset(), "SetLeapMountToHMDOffset"); // 4227202566
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintSpawnableComponent"), TEXT(""));
				MetaData->SetValue(OuterClass, TEXT("ClassGroupNames"), TEXT("Input"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapController.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("Leap Controller class wrapped into an Actor Component.\n\nThe Controller class is your main interface to the Leap Motion Controller.\nCreate an instance of this Controller class to access frames of tracking data\nand configuration information. Frame data can be polled at any time using the\nFrame() function. Call Frame() or Frame(0) to get the most recent\nframe. Set the history parameter to a positive integer to access previous frames.\nA controller stores up to 60 frames in its frame history.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.Controller.html"));
				MetaData->SetValue(NewProp_PEventImage2, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
				MetaData->SetValue(NewProp_PEventImage1, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
				MetaData->SetValue(NewProp_PEventSwipeGesture, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
				MetaData->SetValue(NewProp_PEventScreenTapGesture, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
				MetaData->SetValue(NewProp_PEventKeyTapGesture, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
				MetaData->SetValue(NewProp_PEventCircleGesture, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
				MetaData->SetValue(NewProp_PEventGesture, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
				MetaData->SetValue(NewProp_PEventFinger, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
				MetaData->SetValue(NewProp_PEventHand, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
				MetaData->SetValue(NewProp_PFrame, TEXT("ModuleRelativePath"), TEXT("Public/LeapController.h"));
				MetaData->SetValue(NewProp_PFrame, TEXT("ToolTip"), TEXT("Private UProperties"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapController(Z_Construct_UClass_ULeapController, &ULeapController::StaticClass, TEXT("ULeapController"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapController);
	UFunction* Z_Construct_UFunction_ULeapEventInterface_CircleGestureDetected()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("CircleGestureDetected"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventCircleGestureDetected_Parms));
			UProperty* NewProp_gesture = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("gesture"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(gesture, LeapEventInterface_eventCircleGestureDetected_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapCircleGesture_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("gesture circle detect"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered when a circle gesture is detected.  Gestures need to be enabled in the LeapController to receive their events.\n\n@param Gesture                circle gesture object detected, can be queried to get details of the event such as radius"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_FingerCountChanged()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("FingerCountChanged"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventFingerCountChanged_Parms));
			UProperty* NewProp_count = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("count"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(count, LeapEventInterface_eventFingerCountChanged_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("FingerCountChanged"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("finger count"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered when number of fingers changed from a previous frame.\n\n@param Count          Number of fingers visible"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_GestureDetected()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GestureDetected"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventGestureDetected_Parms));
			UProperty* NewProp_gesture = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("gesture"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(gesture, LeapEventInterface_eventGestureDetected_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapGesture_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("GestureDetected"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("gesture detect"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered when any gesture is detected. Gestures need to be enabled in the LeapController to receive their events.\n\n@param Gesture                gesture object detected, can be cast to a sub-class for specific methods"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_HandCountChanged()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("HandCountChanged"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventHandCountChanged_Parms));
			UProperty* NewProp_count = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("count"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(count, LeapEventInterface_eventHandCountChanged_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("HandCountChanged"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("hand count"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered when number of hands changed from a previous frame.\n\n@param Count          Number of hands visible"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_KeyTapGestureDetected()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("KeyTapGestureDetected"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventKeyTapGestureDetected_Parms));
			UProperty* NewProp_gesture = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("gesture"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(gesture, LeapEventInterface_eventKeyTapGestureDetected_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapKeyTapGesture_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("gesture key tap detect"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered when a key tap gesture is detected.  Gestures need to be enabled in the LeapController to receive their events.\n\n@param Gesture                key tap gesture object detected, can be queried to get details of the event"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapFingerMoved()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapFingerMoved"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventLeapFingerMoved_Parms));
			UProperty* NewProp_finger = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("finger"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(finger, LeapEventInterface_eventLeapFingerMoved_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFinger_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("FingerMoved"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("finger moved"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered for each finger that is visible and tracked.\n\n@param Finger         reference to LeapFinger object containing data for the tracked finger"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapFrontFingerTouch()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapFrontFingerTouch"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventLeapFrontFingerTouch_Parms));
			UProperty* NewProp_finger = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("finger"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(finger, LeapEventInterface_eventLeapFrontFingerTouch_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFinger_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("LeapFrontFingerTouch"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("finger touched"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered only for the frontmost finger when it is touching, defined as\nTouchDistance < 0, a value proportional to the distance between this Pointable object and the adaptive touch plane.\n\n@param Finger         reference to LeapFinger object containing data for the tracked finger"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapFrontMostFingerMoved()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapFrontMostFingerMoved"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventLeapFrontMostFingerMoved_Parms));
			UProperty* NewProp_finger = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("finger"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(finger, LeapEventInterface_eventLeapFrontMostFingerMoved_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFinger_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("FrontFingerMoved"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("finger front most moved"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered for the finger that is frontmost from the perspective of the leap (X Positive) for each visible hand\n\n@param Finger         reference to LeapFinger object containing data for the tracked finger"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapHandGrabbed()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapHandGrabbed"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventLeapHandGrabbed_Parms));
			UProperty* NewProp_hand = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("hand"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(hand, LeapEventInterface_eventLeapHandGrabbed_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapHand_NoRegister());
			UProperty* NewProp_strength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("strength"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(strength, LeapEventInterface_eventLeapHandGrabbed_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("HandGrabbed"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("hand grab"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered when the given hand has grabbed stronger than the grab trigger (grab strength>=0.5)\n\n@param Strength       grabbing strength from 0-1.0\n@param Hand           reference to LeapHand object containing data for the tracked hand"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapHandGrabbing()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapHandGrabbing"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventLeapHandGrabbing_Parms));
			UProperty* NewProp_hand = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("hand"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(hand, LeapEventInterface_eventLeapHandGrabbing_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapHand_NoRegister());
			UProperty* NewProp_strength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("strength"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(strength, LeapEventInterface_eventLeapHandGrabbing_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("HandGrabbing"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("hand grab"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered continuously when the given hand has a grab strength greater than 0.5\n\n@param Strength       grabbing strength from 0-1.0\n@param Hand           reference to LeapHand object containing data for the tracked hand"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapHandMoved()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapHandMoved"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventLeapHandMoved_Parms));
			UProperty* NewProp_hand = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("hand"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(hand, LeapEventInterface_eventLeapHandMoved_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapHand_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("HandMoved"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("hand moved"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered for each hand that is visible and tracked.\n\n@param Hand           reference to LeapHand object containing data for the tracked hand"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapHandPinched()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapHandPinched"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventLeapHandPinched_Parms));
			UProperty* NewProp_hand = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("hand"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(hand, LeapEventInterface_eventLeapHandPinched_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapHand_NoRegister());
			UProperty* NewProp_strength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("strength"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(strength, LeapEventInterface_eventLeapHandPinched_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("HandPinched"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("hand pinch"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered when the given hand has pinched stronger than the pinch trigger (pinch strength>=0.5)\n\n@param Strength       pinch strength from 0-1.0\n@param Hand           reference to LeapHand object containing data for the tracked hand"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapHandPinching()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapHandPinching"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventLeapHandPinching_Parms));
			UProperty* NewProp_hand = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("hand"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(hand, LeapEventInterface_eventLeapHandPinching_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapHand_NoRegister());
			UProperty* NewProp_strength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("strength"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(strength, LeapEventInterface_eventLeapHandPinching_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("HandPinching"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("hand grab"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered continuously when the given hand has a pinch strength greater than 0.5\n\n@param Strength       pinch strength from 0-1.0\n@param Hand           reference to LeapHand object containing data for the tracked hand"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapHandReleased()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapHandReleased"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventLeapHandReleased_Parms));
			UProperty* NewProp_hand = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("hand"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(hand, LeapEventInterface_eventLeapHandReleased_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapHand_NoRegister());
			UProperty* NewProp_strength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("strength"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(strength, LeapEventInterface_eventLeapHandReleased_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("HandReleased"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("hand released ungrab"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered when the given hand's grab strength has fallen below the grab trigger (grab strength<0.5) after having grabbed earlier.\n\n@param Strength       grabbing strength from 0-1.0\n@param Hand           reference to LeapHand object containing data for the tracked hand"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapHandUnpinched()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapHandUnpinched"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventLeapHandUnpinched_Parms));
			UProperty* NewProp_hand = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("hand"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(hand, LeapEventInterface_eventLeapHandUnpinched_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapHand_NoRegister());
			UProperty* NewProp_strength = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("strength"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(strength, LeapEventInterface_eventLeapHandUnpinched_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("HandUnpinched"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("hand unpinch"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered when the given hand's pinch strength has fallen below the pinch trigger (pinch strength<0.5) after having pinched earlier.\n\n@param Strength       pinch strength from 0-1.0\n@param Hand           reference to LeapHand object containing data for the tracked hand"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapLeftHandMoved()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapLeftHandMoved"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventLeapLeftHandMoved_Parms));
			UProperty* NewProp_hand = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("hand"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(hand, LeapEventInterface_eventLeapLeftHandMoved_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapHand_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("LeftHandMoved"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("left hand moved"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered for when the left hand is visible and tracked.\n\n@param Hand           reference to LeapHand object containing data for the tracked hand"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapLeftMostFingerMoved()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapLeftMostFingerMoved"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventLeapLeftMostFingerMoved_Parms));
			UProperty* NewProp_finger = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("finger"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(finger, LeapEventInterface_eventLeapLeftMostFingerMoved_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFinger_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("RightFingerMoved"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("finger right most moved"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered for the finger that is leftmost from the perspective of the leap (YNegative)\n\n@param Finger         reference to LeapFinger object containing data for the tracked finger"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapRightHandMoved()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapRightHandMoved"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventLeapRightHandMoved_Parms));
			UProperty* NewProp_hand = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("hand"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(hand, LeapEventInterface_eventLeapRightHandMoved_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapHand_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("RightHandMoved"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("right hand moved"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered for when the right hand that is visible and tracked.\n\n@param Hand           reference to LeapHand object containing data for the tracked hand"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_LeapRightMostFingerMoved()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("LeapRightMostFingerMoved"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventLeapRightMostFingerMoved_Parms));
			UProperty* NewProp_finger = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("finger"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(finger, LeapEventInterface_eventLeapRightMostFingerMoved_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFinger_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("LeftFingerMoved"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("finger left most moved"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered for the finger that is rightmost from the perspective of the leap (Y Positive) for each visible hand\n\n@param Finger         reference to LeapFinger object containing data for the tracked finger"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_RawImageReceived()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RawImageReceived"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventRawImageReceived_Parms));
			UProperty* NewProp_image = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("image"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(image, LeapEventInterface_eventRawImageReceived_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapImage_NoRegister());
			UProperty* NewProp_texture = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("texture"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(texture, LeapEventInterface_eventRawImageReceived_Parms), 0x0010000000000080, Z_Construct_UClass_UTexture2D_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered when a raw image has been processed.  Raw images need to be enabled in the LeapController to receive their events.\n\n@param Texture                UTexture2D representation of the raw leap image\n@param Image                  image object containing details relevant to the image such as distorion"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_ScreenTapGestureDetected()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ScreenTapGestureDetected"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventScreenTapGestureDetected_Parms));
			UProperty* NewProp_gesture = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("gesture"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(gesture, LeapEventInterface_eventScreenTapGestureDetected_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapScreenTapGesture_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("gesture screen tap detect"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered when a screen tap gesture is detected.  Gestures need to be enabled in the LeapController to receive their events.\n\n@param Gesture                screen tap gesture object detected, can be queried to get details of the event"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapEventInterface_SwipeGestureDetected()
	{
		UObject* Outer=Z_Construct_UClass_ULeapEventInterface();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("SwipeGestureDetected"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x08020800, 65535, sizeof(LeapEventInterface_eventSwipeGestureDetected_Parms));
			UProperty* NewProp_gesture = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("gesture"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(gesture, LeapEventInterface_eventSwipeGestureDetected_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapSwipeGesture_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interface Event"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("gesture swipe detect"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Event triggered when a swipe gesture is detected.  Gestures need to be enabled in the LeapController to receive their events.\n\n@param Gesture                swipe gesture object detected, can be queried to get details of the event"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapEventInterface_NoRegister()
	{
		return ULeapEventInterface::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapEventInterface()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapEventInterface::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20084081;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_CircleGestureDetected());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_FingerCountChanged());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_GestureDetected());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_HandCountChanged());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_KeyTapGestureDetected());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_LeapFingerMoved());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_LeapFrontFingerTouch());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_LeapFrontMostFingerMoved());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_LeapHandGrabbed());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_LeapHandGrabbing());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_LeapHandMoved());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_LeapHandPinched());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_LeapHandPinching());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_LeapHandReleased());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_LeapHandUnpinched());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_LeapLeftHandMoved());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_LeapLeftMostFingerMoved());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_LeapRightHandMoved());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_LeapRightMostFingerMoved());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_RawImageReceived());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_ScreenTapGestureDetected());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapEventInterface_SwipeGestureDetected());

				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_CircleGestureDetected(), "CircleGestureDetected"); // 239378434
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_FingerCountChanged(), "FingerCountChanged"); // 3343120660
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_GestureDetected(), "GestureDetected"); // 2774713915
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_HandCountChanged(), "HandCountChanged"); // 3932994707
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_KeyTapGestureDetected(), "KeyTapGestureDetected"); // 2686406300
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_LeapFingerMoved(), "LeapFingerMoved"); // 1987514992
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_LeapFrontFingerTouch(), "LeapFrontFingerTouch"); // 3326155043
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_LeapFrontMostFingerMoved(), "LeapFrontMostFingerMoved"); // 1841473510
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_LeapHandGrabbed(), "LeapHandGrabbed"); // 3349179779
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_LeapHandGrabbing(), "LeapHandGrabbing"); // 951335657
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_LeapHandMoved(), "LeapHandMoved"); // 4022619948
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_LeapHandPinched(), "LeapHandPinched"); // 722965423
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_LeapHandPinching(), "LeapHandPinching"); // 887221571
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_LeapHandReleased(), "LeapHandReleased"); // 2413323656
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_LeapHandUnpinched(), "LeapHandUnpinched"); // 864725444
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_LeapLeftHandMoved(), "LeapLeftHandMoved"); // 161253437
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_LeapLeftMostFingerMoved(), "LeapLeftMostFingerMoved"); // 681484692
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_LeapRightHandMoved(), "LeapRightHandMoved"); // 4138681915
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_LeapRightMostFingerMoved(), "LeapRightMostFingerMoved"); // 1381584218
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_RawImageReceived(), "RawImageReceived"); // 2098436173
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_ScreenTapGestureDetected(), "ScreenTapGestureDetected"); // 870515622
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapEventInterface_SwipeGestureDetected(), "SwipeGestureDetected"); // 1370311917
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapEventInterface.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapEventInterface(Z_Construct_UClass_ULeapEventInterface, &ULeapEventInterface::StaticClass, TEXT("ULeapEventInterface"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapEventInterface);
	UFunction* Z_Construct_UFunction_ULeapFingerList_Append()
	{
		struct LeapFingerList_eventAppend_Parms
		{
			const ULeapFingerList* List;
			ULeapFingerList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFingerList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Append"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFingerList_eventAppend_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFingerList_eventAppend_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapFingerList_NoRegister());
			UProperty* NewProp_List = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("List"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(List, LeapFingerList_eventAppend_Parms), 0x0010000000000082, Z_Construct_UClass_ULeapFingerList_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Finger List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("append"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("append"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFingerList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Appends the members of the specified FingerList to this FingerList.\n\n@param List - A FingerList object containing Finger objects to append to the end of this FingerList.\n@return the resultant list"));
			MetaData->SetValue(NewProp_List, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFingerList_Extended()
	{
		struct LeapFingerList_eventExtended_Parms
		{
			ULeapFingerList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFingerList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Extended"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFingerList_eventExtended_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFingerList_eventExtended_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapFingerList_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Finger List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("extended"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("extended"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFingerList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns a new list containing those fingers in the current list that are extended.\n\n@return The list of extended fingers from the current list."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFingerList_Frontmost()
	{
		struct LeapFingerList_eventFrontmost_Parms
		{
			ULeapFinger* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFingerList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Frontmost"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFingerList_eventFrontmost_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFingerList_eventFrontmost_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapFinger_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Finger List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("frontmost"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("frontmost"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFingerList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The member of the list that is farthest to the front within the standard Leap Motion frame of reference.\n\n@return The frontmost finger, or invalid if list is empty."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFingerList_GetPointableById()
	{
		struct LeapFingerList_eventGetPointableById_Parms
		{
			int32 Id;
			ULeapFinger* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFingerList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPointableById"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFingerList_eventGetPointableById_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFingerList_eventGetPointableById_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapFinger_NoRegister());
			UProperty* NewProp_Id = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Id"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Id, LeapFingerList_eventGetPointableById_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Finger List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT("[]"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("getPointableById"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get pointable by id"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFingerList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Access a list member by its position in the list.\n\n@return The Finger object at the specified index."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFingerList_Leftmost()
	{
		struct LeapFingerList_eventLeftmost_Parms
		{
			ULeapFinger* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFingerList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Leftmost"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFingerList_eventLeftmost_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFingerList_eventLeftmost_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapFinger_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Finger List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("leftmost"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("leftmost"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFingerList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The member of the list that is farthest to the left within the standard Leap Motion frame of reference\n\n@return The leftmost finger, or invalid if list is empty."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFingerList_Rightmost()
	{
		struct LeapFingerList_eventRightmost_Parms
		{
			ULeapFinger* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFingerList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Rightmost"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFingerList_eventRightmost_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFingerList_eventRightmost_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapFinger_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Finger List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("rightmost"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("rightmost"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFingerList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The member of the list that is farthest to the right within the standard Leap Motion frame of reference\n\n@return The rightmost finger, or invalid if list is empty."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapFingerList_NoRegister()
	{
		return ULeapFingerList::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapFingerList()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapFingerList::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFingerList_Append());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFingerList_Extended());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFingerList_Frontmost());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFingerList_GetPointableById());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFingerList_Leftmost());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFingerList_Rightmost());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PExtendedList = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PExtendedList"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PExtendedList, ULeapFingerList), 0x0040000000000000, Z_Construct_UClass_ULeapFingerList_NoRegister());
				UProperty* NewProp_PAppendedList = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PAppendedList"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PAppendedList, ULeapFingerList), 0x0040000000000000, Z_Construct_UClass_ULeapFingerList_NoRegister());
				UProperty* NewProp_PPointableById = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PPointableById"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PPointableById, ULeapFingerList), 0x0040000000000000, Z_Construct_UClass_ULeapFinger_NoRegister());
				UProperty* NewProp_PRightmost = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PRightmost"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PRightmost, ULeapFingerList), 0x0040000000000000, Z_Construct_UClass_ULeapFinger_NoRegister());
				UProperty* NewProp_PLeftmost = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PLeftmost"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PLeftmost, ULeapFingerList), 0x0040000000000000, Z_Construct_UClass_ULeapFinger_NoRegister());
				UProperty* NewProp_PFrontmost = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PFrontmost"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PFrontmost, ULeapFingerList), 0x0040000000000000, Z_Construct_UClass_ULeapFinger_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsEmpty, ULeapFingerList, bool);
				UProperty* NewProp_IsEmpty = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsEmpty"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsEmpty, ULeapFingerList), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsEmpty, ULeapFingerList), sizeof(bool), true);
				UProperty* NewProp_Count = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Count"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Count, ULeapFingerList), 0x0010000000000015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFingerList_Append(), "Append"); // 2500095470
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFingerList_Extended(), "Extended"); // 2597421183
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFingerList_Frontmost(), "Frontmost"); // 2420248342
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFingerList_GetPointableById(), "GetPointableById"); // 1173276614
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFingerList_Leftmost(), "Leftmost"); // 1632461500
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFingerList_Rightmost(), "Rightmost"); // 1966937299
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapFingerList.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapFingerList.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The FingerList class represents a list of Finger objects.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.FingerList.html"));
				MetaData->SetValue(NewProp_PExtendedList, TEXT("ModuleRelativePath"), TEXT("Public/LeapFingerList.h"));
				MetaData->SetValue(NewProp_PAppendedList, TEXT("ModuleRelativePath"), TEXT("Public/LeapFingerList.h"));
				MetaData->SetValue(NewProp_PPointableById, TEXT("ModuleRelativePath"), TEXT("Public/LeapFingerList.h"));
				MetaData->SetValue(NewProp_PRightmost, TEXT("ModuleRelativePath"), TEXT("Public/LeapFingerList.h"));
				MetaData->SetValue(NewProp_PLeftmost, TEXT("ModuleRelativePath"), TEXT("Public/LeapFingerList.h"));
				MetaData->SetValue(NewProp_PFrontmost, TEXT("ModuleRelativePath"), TEXT("Public/LeapFingerList.h"));
				MetaData->SetValue(NewProp_IsEmpty, TEXT("Category"), TEXT("Leap Finger List"));
				MetaData->SetValue(NewProp_IsEmpty, TEXT("ModuleRelativePath"), TEXT("Public/LeapFingerList.h"));
				MetaData->SetValue(NewProp_Count, TEXT("Category"), TEXT("Leap Finger List"));
				MetaData->SetValue(NewProp_Count, TEXT("ModuleRelativePath"), TEXT("Public/LeapFingerList.h"));
				MetaData->SetValue(NewProp_Count, TEXT("ToolTip"), TEXT("Number of fingers in this list."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapFingerList(Z_Construct_UClass_ULeapFingerList, &ULeapFingerList::StaticClass, TEXT("ULeapFingerList"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapFingerList);
	UFunction* Z_Construct_UFunction_ULeapFrame_Finger()
	{
		struct LeapFrame_eventFinger_Parms
		{
			int32 Id;
			ULeapFinger* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Finger"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventFinger_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventFinger_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapFinger_NoRegister());
			UProperty* NewProp_Id = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Id"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Id, LeapFrame_eventFinger_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The Finger object with the specified ID in this frame.\n\n@param        Id The ID value of a Finger object from a previous frame.\n@return       The Finger object with the matching ID if one exists in this frame; otherwise, an invalid Finger object is returned."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_Fingers()
	{
		struct LeapFrame_eventFingers_Parms
		{
			ULeapFingerList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Fingers"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventFingers_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventFingers_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapFingerList_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("fingers"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get fingers"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The list of Finger objects detected in this frame, given in arbitrary order.\n\n@return       The FingerList containing all Finger objects detected in this frame."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_Gesture()
	{
		struct LeapFrame_eventGesture_Parms
		{
			int32 Id;
			ULeapGesture* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Gesture"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventGesture_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventGesture_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapGesture_NoRegister());
			UProperty* NewProp_Id = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Id"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Id, LeapFrame_eventGesture_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The Gesture object with the specified ID in this frame.\n\n@param                Id The ID of an Gesture object from a previous frame.\n@return The Gesture object in the frame with the specified ID if one exists; Otherwise, an Invalid Gesture object."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_Gestures()
	{
		struct LeapFrame_eventGestures_Parms
		{
			ULeapGestureList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Gestures"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventGestures_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventGestures_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapGestureList_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("gestures"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get gestures"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The gestures recognized or continuing in this frame.\n\n@return the list of gestures."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_GesturesSinceFrame()
	{
		struct LeapFrame_eventGesturesSinceFrame_Parms
		{
			ULeapFrame* frame;
			ULeapGestureList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GesturesSinceFrame"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventGesturesSinceFrame_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventGesturesSinceFrame_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapGestureList_NoRegister());
			UProperty* NewProp_frame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("frame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(frame, LeapFrame_eventGesturesSinceFrame_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("gestures"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get gestures"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns a GestureList containing all gestures that have occurred since the specified frame.\n\n@param                Frame An earlier Frame object. The starting frame must still be in the frame history cache, which has a default length of 60 frames.\n@return GestureList The list of the Gesture objects that have occurred since the specified frame."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_Hand()
	{
		struct LeapFrame_eventHand_Parms
		{
			int32 Id;
			ULeapHand* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Hand"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventHand_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventHand_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapHand_NoRegister());
			UProperty* NewProp_Id = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Id"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Id, LeapFrame_eventHand_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The Hand object with the specified ID in this frame.\n\n@param                Id The ID value of a Hand object from a previous frame.\n@return The Hand object with the matching ID if one exists in this frame; otherwise, an invalid Hand object is returned."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_Hands()
	{
		struct LeapFrame_eventHands_Parms
		{
			ULeapHandList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Hands"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventHands_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventHands_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapHandList_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("getHands"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get hands"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The list of Hand objects detected in this frame, given in arbitrary order.\n\n@return The HandList containing all Hand objects detected in this frame."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_Images()
	{
		struct LeapFrame_eventImages_Parms
		{
			ULeapImageList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Images"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventImages_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventImages_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapImageList_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("images"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get images"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The list of images from the Leap Motion cameras.\n\n@return An ImageList object containing the camera images analyzed to create this Frame."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_InteractionBox()
	{
		struct LeapFrame_eventInteractionBox_Parms
		{
			ULeapInteractionBox* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("InteractionBox"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventInteractionBox_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventInteractionBox_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapInteractionBox_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("interactionBox"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get interaction box"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The current InteractionBox for the frame.\n\n@return The current InteractionBox object."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_Pointable()
	{
		struct LeapFrame_eventPointable_Parms
		{
			int32 Id;
			ULeapPointable* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Pointable"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventPointable_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventPointable_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapPointable_NoRegister());
			UProperty* NewProp_Id = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Id"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Id, LeapFrame_eventPointable_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The Pointable object with the specified ID in this frame.\n\n@param                Id The ID value of a Pointable object from a previous frame.\n@return The Pointable object with the matching ID if one exists in this frame; otherwise, an invalid Pointable object is returned."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_Pointables()
	{
		struct LeapFrame_eventPointables_Parms
		{
			ULeapPointableList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Pointables"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventPointables_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventPointables_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapPointableList_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("pointables"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get pointables"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The list of Pointable objects (fingers and tools) detected in this frame, given in arbitrary order.\n\n@return The PointableList containing all Pointable objects detected in this frame."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_RotationAngle()
	{
		struct LeapFrame_eventRotationAngle_Parms
		{
			ULeapFrame* Frame;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RotationAngle"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventRotationAngle_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventRotationAngle_Parms), 0x0010000000000580);
			UProperty* NewProp_Frame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Frame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Frame, LeapFrame_eventRotationAngle_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The angle of rotation around the rotation axis derived from the overall rotational motion between the current frame and the specified frame.\n\n@param Frame  The starting frame for computing the relative rotation.\n@return A positive value containing the heuristically determined rotational change between the current frame and that specified in the sinceFrame parameter."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_RotationAngleAroundAxis()
	{
		struct LeapFrame_eventRotationAngleAroundAxis_Parms
		{
			ULeapFrame* Frame;
			FVector Axis;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RotationAngleAroundAxis"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(LeapFrame_eventRotationAngleAroundAxis_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventRotationAngleAroundAxis_Parms), 0x0010000000000580);
			UProperty* NewProp_Axis = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Axis"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Axis, LeapFrame_eventRotationAngleAroundAxis_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Frame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Frame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Frame, LeapFrame_eventRotationAngleAroundAxis_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The angle of rotation around the specified axis derived from the overall rotational motion between the current frame and the specified frame.\n\n@param Frame  The starting frame for computing the relative rotation.\n@param Axis   The axis to measure rotation around.\n@return A value containing the heuristically determined rotational change between the current frame and that specified in the sinceFrame parameter around the given axis."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_RotationAxis()
	{
		struct LeapFrame_eventRotationAxis_Parms
		{
			ULeapFrame* Frame;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RotationAxis"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(LeapFrame_eventRotationAxis_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventRotationAxis_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Frame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Frame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Frame, LeapFrame_eventRotationAxis_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The axis of rotation derived from the overall rotational motion between the current frame and the specified frame.\n\n@param Frame  The starting frame for computing the relative rotation.\n@return A normalized direction Vector representing the axis of the heuristically determined rotational change between the current frame and that specified in the sinceFrame parameter."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_RotationProbability()
	{
		struct LeapFrame_eventRotationProbability_Parms
		{
			ULeapFrame* Frame;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RotationProbability"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventRotationProbability_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventRotationProbability_Parms), 0x0010000000000580);
			UProperty* NewProp_Frame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Frame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Frame, LeapFrame_eventRotationProbability_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The estimated probability that the overall motion between the current frame and the specified frame is intended to be a rotating motion.\n\n@param Frame  The starting frame for computing the relative rotation.\n@return A value between 0 and 1 representing the estimated probability that the overall motion between the current frame and the specified frame is intended to be a rotating motion."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_ScaleFactor()
	{
		struct LeapFrame_eventScaleFactor_Parms
		{
			ULeapFrame* Frame;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ScaleFactor"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventScaleFactor_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventScaleFactor_Parms), 0x0010000000000580);
			UProperty* NewProp_Frame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Frame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Frame, LeapFrame_eventScaleFactor_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The scale factor derived from the overall motion between the current frame and the specified frame.\n\n@param Frame  The starting frame for computing the relative scaling.\n@return A positive value representing the heuristically determined scaling change ratio between the current frame and that specified in the sinceFrame parameter."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_ScaleProbability()
	{
		struct LeapFrame_eventScaleProbability_Parms
		{
			ULeapFrame* Frame;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ScaleProbability"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventScaleProbability_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventScaleProbability_Parms), 0x0010000000000580);
			UProperty* NewProp_Frame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Frame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Frame, LeapFrame_eventScaleProbability_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The estimated probability that the overall motion between the current frame and the specified frame is intended to be a scaling motion.\n\n@param Frame  The starting frame for computing the relative scaling.\n@return A value between 0 and 1 representing the estimated probability that the overall motion between the current frame and the specified frame is intended to be a scaling motion."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_Tool()
	{
		struct LeapFrame_eventTool_Parms
		{
			int32 Id;
			ULeapTool* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Tool"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventTool_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventTool_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapTool_NoRegister());
			UProperty* NewProp_Id = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Id"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Id, LeapFrame_eventTool_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The Tool object with the specified ID in this frame.\n\n@param Id             The ID value of a Tool object from a previous frame.\n@return The Tool object with the matching ID if one exists in this frame; otherwise, an invalid Tool object is returned."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_Tools()
	{
		struct LeapFrame_eventTools_Parms
		{
			ULeapToolList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Tools"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventTools_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventTools_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapToolList_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("pointables"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get pointables"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The list of Tool objects detected in this frame, given in arbitrary order.\n\n@return The ToolList containing all Tool objects detected in this frame."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_Translation()
	{
		struct LeapFrame_eventTranslation_Parms
		{
			ULeapFrame* Frame;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Translation"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04820401, 65535, sizeof(LeapFrame_eventTranslation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventTranslation_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Frame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Frame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Frame, LeapFrame_eventTranslation_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The change of position derived from the overall linear motion between the current frame and the specified frame.\n\n@param Frame  The starting frame for computing the relative translation.\n@return A Vector representing the heuristically determined change in position of all objects between the current frame and that specified in the frame parameter."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapFrame_TranslationProbability()
	{
		struct LeapFrame_eventTranslationProbability_Parms
		{
			ULeapFrame* Frame;
			float ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFrame();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("TranslationProbability"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFrame_eventTranslationProbability_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFrame_eventTranslationProbability_Parms), 0x0010000000000580);
			UProperty* NewProp_Frame = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Frame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Frame, LeapFrame_eventTranslationProbability_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The estimated probability that the overall motion between the current frame and the specified frame is intended to be a translating motion.\n\n@param Frame  The starting frame for computing the translation.\n@return A value between 0 and 1 representing the estimated probability that the overall motion between the current frame and the specified frame is intended to be a translating motion."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapFrame_NoRegister()
	{
		return ULeapFrame::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapFrame()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapFrame::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_Finger());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_Fingers());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_Gesture());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_Gestures());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_GesturesSinceFrame());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_Hand());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_Hands());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_Images());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_InteractionBox());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_Pointable());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_Pointables());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_RotationAngle());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_RotationAngleAroundAxis());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_RotationAxis());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_RotationProbability());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_ScaleFactor());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_ScaleProbability());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_Tool());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_Tools());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_Translation());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFrame_TranslationProbability());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PTools = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PTools"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PTools, ULeapFrame), 0x0040000000000000, Z_Construct_UClass_ULeapToolList_NoRegister());
				UProperty* NewProp_PTool = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PTool"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PTool, ULeapFrame), 0x0040000000000000, Z_Construct_UClass_ULeapTool_NoRegister());
				UProperty* NewProp_PPointables = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PPointables"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PPointables, ULeapFrame), 0x0040000000000000, Z_Construct_UClass_ULeapPointableList_NoRegister());
				UProperty* NewProp_PPointable = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PPointable"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PPointable, ULeapFrame), 0x0040000000000000, Z_Construct_UClass_ULeapPointable_NoRegister());
				UProperty* NewProp_PInteractionBox = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PInteractionBox"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PInteractionBox, ULeapFrame), 0x0040000000000000, Z_Construct_UClass_ULeapInteractionBox_NoRegister());
				UProperty* NewProp_PImages = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PImages"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PImages, ULeapFrame), 0x0040000000000000, Z_Construct_UClass_ULeapImageList_NoRegister());
				UProperty* NewProp_PHands = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PHands"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PHands, ULeapFrame), 0x0040000000000000, Z_Construct_UClass_ULeapHandList_NoRegister());
				UProperty* NewProp_PHand = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PHand"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PHand, ULeapFrame), 0x0040000000000000, Z_Construct_UClass_ULeapHand_NoRegister());
				UProperty* NewProp_PGestures = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PGestures"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PGestures, ULeapFrame), 0x0040000000000000, Z_Construct_UClass_ULeapGestureList_NoRegister());
				UProperty* NewProp_PGesture = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PGesture"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PGesture, ULeapFrame), 0x0040000000000000, Z_Construct_UClass_ULeapGesture_NoRegister());
				UProperty* NewProp_PFingers = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PFingers"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PFingers, ULeapFrame), 0x0040000000000000, Z_Construct_UClass_ULeapFingerList_NoRegister());
				UProperty* NewProp_PFinger = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PFinger"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PFinger, ULeapFrame), 0x0040000000000000, Z_Construct_UClass_ULeapFinger_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsValid, ULeapFrame, bool);
				UProperty* NewProp_IsValid = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsValid"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsValid, ULeapFrame), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsValid, ULeapFrame), sizeof(bool), true);
				UProperty* NewProp_CurrentFPS = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CurrentFPS"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(CurrentFPS, ULeapFrame), 0x0010000000000015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_Finger(), "Finger"); // 242544572
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_Fingers(), "Fingers"); // 486793874
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_Gesture(), "Gesture"); // 3669737867
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_Gestures(), "Gestures"); // 3940806485
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_GesturesSinceFrame(), "GesturesSinceFrame"); // 1879665074
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_Hand(), "Hand"); // 3371078468
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_Hands(), "Hands"); // 161625262
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_Images(), "Images"); // 3754623042
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_InteractionBox(), "InteractionBox"); // 1141624614
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_Pointable(), "Pointable"); // 974010222
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_Pointables(), "Pointables"); // 3072334419
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_RotationAngle(), "RotationAngle"); // 1127258546
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_RotationAngleAroundAxis(), "RotationAngleAroundAxis"); // 3146653355
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_RotationAxis(), "RotationAxis"); // 1215940410
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_RotationProbability(), "RotationProbability"); // 3004839123
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_ScaleFactor(), "ScaleFactor"); // 80138353
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_ScaleProbability(), "ScaleProbability"); // 2496097982
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_Tool(), "Tool"); // 1814066962
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_Tools(), "Tools"); // 1957272117
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_Translation(), "Translation"); // 2031717004
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFrame_TranslationProbability(), "TranslationProbability"); // 2299032193
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapFrame.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The Frame class represents a set of hand and finger tracking data detected\nin a single frame.\n\nThe Leap Motion software detects hands, fingers and tools within the tracking\narea, reporting their positions, orientations, gestures, and motions in frames\nat the Leap Motion frame rate.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.Frame.html"));
				MetaData->SetValue(NewProp_PTools, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
				MetaData->SetValue(NewProp_PTool, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
				MetaData->SetValue(NewProp_PPointables, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
				MetaData->SetValue(NewProp_PPointable, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
				MetaData->SetValue(NewProp_PInteractionBox, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
				MetaData->SetValue(NewProp_PImages, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
				MetaData->SetValue(NewProp_PHands, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
				MetaData->SetValue(NewProp_PHand, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
				MetaData->SetValue(NewProp_PGestures, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
				MetaData->SetValue(NewProp_PGesture, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
				MetaData->SetValue(NewProp_PFingers, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
				MetaData->SetValue(NewProp_PFinger, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
				MetaData->SetValue(NewProp_IsValid, TEXT("Category"), TEXT("Leap Frame"));
				MetaData->SetValue(NewProp_IsValid, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
				MetaData->SetValue(NewProp_IsValid, TEXT("ToolTip"), TEXT("Whether this Frame instance is valid."));
				MetaData->SetValue(NewProp_CurrentFPS, TEXT("Category"), TEXT("Leap Frame"));
				MetaData->SetValue(NewProp_CurrentFPS, TEXT("ModuleRelativePath"), TEXT("Public/LeapFrame.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapFrame(Z_Construct_UClass_ULeapFrame, &ULeapFrame::StaticClass, TEXT("ULeapFrame"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapFrame);
	UFunction* Z_Construct_UFunction_ULeapCircleGesture_Pointable()
	{
		struct LeapCircleGesture_eventPointable_Parms
		{
			ULeapPointable* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapCircleGesture();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Pointable"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapCircleGesture_eventPointable_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapCircleGesture_eventPointable_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapPointable_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Circle Gesture"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapCircleGesture.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("@return The finger performing the circle gesture."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapCircleGesture_NoRegister()
	{
		return ULeapCircleGesture::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapCircleGesture()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ULeapGesture();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapCircleGesture::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapCircleGesture_Pointable());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PPointable = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PPointable"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PPointable, ULeapCircleGesture), 0x0040000000000000, Z_Construct_UClass_ULeapPointable_NoRegister());
				UProperty* NewProp_Radius = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Radius"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Radius, ULeapCircleGesture), 0x0010000000000015);
				UProperty* NewProp_Progress = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Progress"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Progress, ULeapCircleGesture), 0x0010000000000015);
				UProperty* NewProp_Normal = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Normal"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Normal, ULeapCircleGesture), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Center = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Center"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Center, ULeapCircleGesture), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapCircleGesture_Pointable(), "Pointable"); // 2933770089
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapCircleGesture.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapCircleGesture.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The CircleGesture classes represents a circular finger movement.\nA circle movement is recognized when the tip of a finger draws a circle within\nthe Leap Motion Controller field of view.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.CircleGesture.html"));
				MetaData->SetValue(NewProp_PPointable, TEXT("ModuleRelativePath"), TEXT("Public/LeapCircleGesture.h"));
				MetaData->SetValue(NewProp_Radius, TEXT("Category"), TEXT("Leap Circle Gesture"));
				MetaData->SetValue(NewProp_Radius, TEXT("ModuleRelativePath"), TEXT("Public/LeapCircleGesture.h"));
				MetaData->SetValue(NewProp_Radius, TEXT("ToolTip"), TEXT("The radius of the circle."));
				MetaData->SetValue(NewProp_Progress, TEXT("Category"), TEXT("Leap Circle Gesture"));
				MetaData->SetValue(NewProp_Progress, TEXT("ModuleRelativePath"), TEXT("Public/LeapCircleGesture.h"));
				MetaData->SetValue(NewProp_Progress, TEXT("ToolTip"), TEXT("The number of times the finger tip has traversed the circle."));
				MetaData->SetValue(NewProp_Normal, TEXT("Category"), TEXT("Leap Circle Gesture"));
				MetaData->SetValue(NewProp_Normal, TEXT("ModuleRelativePath"), TEXT("Public/LeapCircleGesture.h"));
				MetaData->SetValue(NewProp_Normal, TEXT("ToolTip"), TEXT("Returns the normal vector for the circle being traced."));
				MetaData->SetValue(NewProp_Center, TEXT("Category"), TEXT("Leap Circle Gesture"));
				MetaData->SetValue(NewProp_Center, TEXT("ModuleRelativePath"), TEXT("Public/LeapCircleGesture.h"));
				MetaData->SetValue(NewProp_Center, TEXT("ToolTip"), TEXT("The center point of the circle within the Leap Motion frame of reference."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapCircleGesture(Z_Construct_UClass_ULeapCircleGesture, &ULeapCircleGesture::StaticClass, TEXT("ULeapCircleGesture"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapCircleGesture);
	UFunction* Z_Construct_UFunction_ULeapKeyTapGesture_Pointable()
	{
		struct LeapKeyTapGesture_eventPointable_Parms
		{
			ULeapPointable* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapKeyTapGesture();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Pointable"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapKeyTapGesture_eventPointable_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapKeyTapGesture_eventPointable_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapPointable_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Key Tap Gesture"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapKeyTapGesture.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The finger performing the key tap gesture.\n\n@return       A Pointable object representing the tapping finger."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapKeyTapGesture_NoRegister()
	{
		return ULeapKeyTapGesture::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapKeyTapGesture()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ULeapGesture();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapKeyTapGesture::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapKeyTapGesture_Pointable());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PPointable = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PPointable"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PPointable, ULeapKeyTapGesture), 0x0040000000000000, Z_Construct_UClass_ULeapPointable_NoRegister());
				UProperty* NewProp_Progress = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Progress"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Progress, ULeapKeyTapGesture), 0x0010000000000015);
				UProperty* NewProp_Position = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Position"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Position, ULeapKeyTapGesture), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Direction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Direction"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Direction, ULeapKeyTapGesture), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_BasicDirection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BasicDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(BasicDirection, ULeapKeyTapGesture), 0x0010000000000015, Z_Construct_UEnum_LeapMotion_LeapBasicDirection());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapKeyTapGesture_Pointable(), "Pointable"); // 3994126422
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapKeyTapGesture.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapKeyTapGesture.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The KeyTapGesture class represents a tapping gesture by a finger or tool.\nA key tap gesture is recognized when the tip of a finger rotates down toward\nthe palm and then springs back to approximately the original position, as if\ntapping.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.KeyTapGesture.html"));
				MetaData->SetValue(NewProp_PPointable, TEXT("ModuleRelativePath"), TEXT("Public/LeapKeyTapGesture.h"));
				MetaData->SetValue(NewProp_Progress, TEXT("Category"), TEXT("Leap Key Tap Gesture"));
				MetaData->SetValue(NewProp_Progress, TEXT("ModuleRelativePath"), TEXT("Public/LeapKeyTapGesture.h"));
				MetaData->SetValue(NewProp_Progress, TEXT("ToolTip"), TEXT("The progress value is always 1.0 for a key tap gesture."));
				MetaData->SetValue(NewProp_Position, TEXT("Category"), TEXT("Leap Key Tap Gesture"));
				MetaData->SetValue(NewProp_Position, TEXT("ModuleRelativePath"), TEXT("Public/LeapKeyTapGesture.h"));
				MetaData->SetValue(NewProp_Position, TEXT("ToolTip"), TEXT("The position where the key tap is registered."));
				MetaData->SetValue(NewProp_Direction, TEXT("Category"), TEXT("Leap Key Tap Gesture"));
				MetaData->SetValue(NewProp_Direction, TEXT("ModuleRelativePath"), TEXT("Public/LeapKeyTapGesture.h"));
				MetaData->SetValue(NewProp_Direction, TEXT("ToolTip"), TEXT("The direction of finger tip motion."));
				MetaData->SetValue(NewProp_BasicDirection, TEXT("Category"), TEXT("Leap Key Tap  Gesture"));
				MetaData->SetValue(NewProp_BasicDirection, TEXT("ModuleRelativePath"), TEXT("Public/LeapKeyTapGesture.h"));
				MetaData->SetValue(NewProp_BasicDirection, TEXT("ToolTip"), TEXT("The direction of finger tip motion in basic enum form, useful for switching\nthrough common directions checks (Up/Down, Left/Right, In/Out)"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapKeyTapGesture(Z_Construct_UClass_ULeapKeyTapGesture, &ULeapKeyTapGesture::StaticClass, TEXT("ULeapKeyTapGesture"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapKeyTapGesture);
	UFunction* Z_Construct_UFunction_ULeapScreenTapGesture_Pointable()
	{
		struct LeapScreenTapGesture_eventPointable_Parms
		{
			ULeapPointable* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapScreenTapGesture();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Pointable"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapScreenTapGesture_eventPointable_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapScreenTapGesture_eventPointable_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapPointable_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Screen Tap Gesture"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapScreenTapGesture.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The finger performing the screen tap gesture.\n\n@return       A Pointable object representing the tapping finger."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapScreenTapGesture_NoRegister()
	{
		return ULeapScreenTapGesture::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapScreenTapGesture()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ULeapGesture();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapScreenTapGesture::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapScreenTapGesture_Pointable());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PPointable = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PPointable"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PPointable, ULeapScreenTapGesture), 0x0040000000000000, Z_Construct_UClass_ULeapPointable_NoRegister());
				UProperty* NewProp_Progress = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Progress"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Progress, ULeapScreenTapGesture), 0x0010000000000015);
				UProperty* NewProp_Position = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Position"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Position, ULeapScreenTapGesture), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Direction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Direction"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Direction, ULeapScreenTapGesture), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_BasicDirection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BasicDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(BasicDirection, ULeapScreenTapGesture), 0x0010000000000015, Z_Construct_UEnum_LeapMotion_LeapBasicDirection());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapScreenTapGesture_Pointable(), "Pointable"); // 444055841
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapScreenTapGesture.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapScreenTapGesture.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The ScreenTapGesture class represents a tapping gesture by a finger or tool.\nA screen tap gesture is recognized when the tip of a finger pokes forward and\nthen springs back to approximately the original position, as if tapping a vertical\nscreen. The tapping finger must pause briefly before beginning the tap.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.ScreenTapGesture.html"));
				MetaData->SetValue(NewProp_PPointable, TEXT("ModuleRelativePath"), TEXT("Public/LeapScreenTapGesture.h"));
				MetaData->SetValue(NewProp_Progress, TEXT("Category"), TEXT("Leap Screen Tap Gesture"));
				MetaData->SetValue(NewProp_Progress, TEXT("ModuleRelativePath"), TEXT("Public/LeapScreenTapGesture.h"));
				MetaData->SetValue(NewProp_Progress, TEXT("ToolTip"), TEXT("The progress value is always 1.0 for a screen tap gesture."));
				MetaData->SetValue(NewProp_Position, TEXT("Category"), TEXT("Leap Screen Tap Gesture"));
				MetaData->SetValue(NewProp_Position, TEXT("ModuleRelativePath"), TEXT("Public/LeapScreenTapGesture.h"));
				MetaData->SetValue(NewProp_Position, TEXT("ToolTip"), TEXT("The position where the screen tap is registered."));
				MetaData->SetValue(NewProp_Direction, TEXT("Category"), TEXT("Leap Screen Tap Gesture"));
				MetaData->SetValue(NewProp_Direction, TEXT("ModuleRelativePath"), TEXT("Public/LeapScreenTapGesture.h"));
				MetaData->SetValue(NewProp_Direction, TEXT("ToolTip"), TEXT("The direction of finger tip motion."));
				MetaData->SetValue(NewProp_BasicDirection, TEXT("Category"), TEXT("Leap Screen Tap  Gesture"));
				MetaData->SetValue(NewProp_BasicDirection, TEXT("ModuleRelativePath"), TEXT("Public/LeapScreenTapGesture.h"));
				MetaData->SetValue(NewProp_BasicDirection, TEXT("ToolTip"), TEXT("The direction of finger tip motion in basic enum form, useful for switching\nthrough common directions checks (Up/Down, Left/Right, In/Out)"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapScreenTapGesture(Z_Construct_UClass_ULeapScreenTapGesture, &ULeapScreenTapGesture::StaticClass, TEXT("ULeapScreenTapGesture"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapScreenTapGesture);
	UFunction* Z_Construct_UFunction_ULeapSwipeGesture_Pointable()
	{
		struct LeapSwipeGesture_eventPointable_Parms
		{
			ULeapPointable* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapSwipeGesture();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Pointable"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapSwipeGesture_eventPointable_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapSwipeGesture_eventPointable_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapPointable_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Swipe Gesture"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapSwipeGesture.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The finger performing the swipe gesture.\n\n@return       A Pointable object representing the swiping finger."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapSwipeGesture_NoRegister()
	{
		return ULeapSwipeGesture::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapSwipeGesture()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ULeapGesture();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapSwipeGesture::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapSwipeGesture_Pointable());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PPointable = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PPointable"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PPointable, ULeapSwipeGesture), 0x0040000000000000, Z_Construct_UClass_ULeapPointable_NoRegister());
				UProperty* NewProp_StartPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StartPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(StartPosition, ULeapSwipeGesture), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Speed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Speed"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Speed, ULeapSwipeGesture), 0x0010000000000015);
				UProperty* NewProp_Position = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Position"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Position, ULeapSwipeGesture), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Direction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Direction"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Direction, ULeapSwipeGesture), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_BasicDirection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("BasicDirection"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(BasicDirection, ULeapSwipeGesture), 0x0010000000000015, Z_Construct_UEnum_LeapMotion_LeapBasicDirection());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapSwipeGesture_Pointable(), "Pointable"); // 3129726184
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapSwipeGesture.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapSwipeGesture.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The SwipeGesture class represents a swiping motion a finger or tool.\nSwipeGesture objects are generated for each visible finger or tool.\nSwipe gestures are continuous; a gesture object with the same ID value\nwill appear in each frame while the gesture continues.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.SwipeGesture.html"));
				MetaData->SetValue(NewProp_PPointable, TEXT("ModuleRelativePath"), TEXT("Public/LeapSwipeGesture.h"));
				MetaData->SetValue(NewProp_StartPosition, TEXT("Category"), TEXT("Leap Swipe Gesture"));
				MetaData->SetValue(NewProp_StartPosition, TEXT("ModuleRelativePath"), TEXT("Public/LeapSwipeGesture.h"));
				MetaData->SetValue(NewProp_StartPosition, TEXT("ToolTip"), TEXT("The position where the swipe began."));
				MetaData->SetValue(NewProp_Speed, TEXT("Category"), TEXT("Leap Swipe Gesture"));
				MetaData->SetValue(NewProp_Speed, TEXT("ModuleRelativePath"), TEXT("Public/LeapSwipeGesture.h"));
				MetaData->SetValue(NewProp_Speed, TEXT("ToolTip"), TEXT("The swipe speed in cm/second."));
				MetaData->SetValue(NewProp_Position, TEXT("Category"), TEXT("Leap Swipe Gesture"));
				MetaData->SetValue(NewProp_Position, TEXT("ModuleRelativePath"), TEXT("Public/LeapSwipeGesture.h"));
				MetaData->SetValue(NewProp_Position, TEXT("ToolTip"), TEXT("The current position of the swipe."));
				MetaData->SetValue(NewProp_Direction, TEXT("Category"), TEXT("Leap Swipe Gesture"));
				MetaData->SetValue(NewProp_Direction, TEXT("ModuleRelativePath"), TEXT("Public/LeapSwipeGesture.h"));
				MetaData->SetValue(NewProp_Direction, TEXT("ToolTip"), TEXT("The unit direction vector parallel to the swipe motion."));
				MetaData->SetValue(NewProp_BasicDirection, TEXT("Category"), TEXT("Leap Swipe Gesture"));
				MetaData->SetValue(NewProp_BasicDirection, TEXT("ModuleRelativePath"), TEXT("Public/LeapSwipeGesture.h"));
				MetaData->SetValue(NewProp_BasicDirection, TEXT("ToolTip"), TEXT("The unit direction vector parallel to the swipe motion in basic enum form, useful for switching through common directions checks (Up/Down, Left/Right, In/Out)"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapSwipeGesture(Z_Construct_UClass_ULeapSwipeGesture, &ULeapSwipeGesture::StaticClass, TEXT("ULeapSwipeGesture"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapSwipeGesture);
	UFunction* Z_Construct_UFunction_ULeapGestureList_GetIndex()
	{
		struct LeapGestureList_eventGetIndex_Parms
		{
			int32 Index;
			ULeapGesture* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapGestureList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapGestureList_eventGetIndex_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapGestureList_eventGetIndex_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapGesture_NoRegister());
			UProperty* NewProp_Index = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Index"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Index, LeapGestureList_eventGetIndex_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Gesture List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT("[]"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("getIndex"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get index"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapGestureList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Access a list member by its position in the list.\n\n@param index  The zero-based list position index.\n@return               The Gesture object at the specified index."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapGestureList_NoRegister()
	{
		return ULeapGestureList::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapGestureList()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapGestureList::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapGestureList_GetIndex());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Gesture = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Gesture"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Gesture, ULeapGestureList), 0x0040000000000000, Z_Construct_UClass_ULeapGesture_NoRegister());
				UProperty* NewProp_Count = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Count"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Count, ULeapGestureList), 0x0010000000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsEmpty, ULeapGestureList, bool);
				UProperty* NewProp_IsEmpty = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsEmpty"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsEmpty, ULeapGestureList), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsEmpty, ULeapGestureList), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapGestureList_GetIndex(), "GetIndex"); // 3923087215
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapGestureList.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapGestureList.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The GestureList class represents a list of Gesture objects.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.GestureList.html"));
				MetaData->SetValue(NewProp_Gesture, TEXT("ModuleRelativePath"), TEXT("Public/LeapGestureList.h"));
				MetaData->SetValue(NewProp_Count, TEXT("Category"), TEXT("Leap Gesture List"));
				MetaData->SetValue(NewProp_Count, TEXT("ModuleRelativePath"), TEXT("Public/LeapGestureList.h"));
				MetaData->SetValue(NewProp_Count, TEXT("ToolTip"), TEXT("The length of this list."));
				MetaData->SetValue(NewProp_IsEmpty, TEXT("Category"), TEXT("Leap Gesture List"));
				MetaData->SetValue(NewProp_IsEmpty, TEXT("ModuleRelativePath"), TEXT("Public/LeapGestureList.h"));
				MetaData->SetValue(NewProp_IsEmpty, TEXT("ToolTip"), TEXT("Reports whether the list is empty."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapGestureList(Z_Construct_UClass_ULeapGestureList, &ULeapGestureList::StaticClass, TEXT("ULeapGestureList"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapGestureList);
	UFunction* Z_Construct_UFunction_ULeapHandList_Frontmost()
	{
		struct LeapHandList_eventFrontmost_Parms
		{
			ULeapHand* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapHandList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Frontmost"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapHandList_eventFrontmost_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapHandList_eventFrontmost_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapHand_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Hand List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("getFrontmost"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get frontmost"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapHandList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The member of the list that is farthest to the front within the standard Leap Motion frame of reference (i.e has the largest X coordinate).\n\n@return       The frontmost hand, or invalid if list is empty."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapHandList_GetIndex()
	{
		struct LeapHandList_eventGetIndex_Parms
		{
			int32 Index;
			ULeapHand* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapHandList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapHandList_eventGetIndex_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapHandList_eventGetIndex_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapHand_NoRegister());
			UProperty* NewProp_Index = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Index"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Index, LeapHandList_eventGetIndex_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Hand List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("getIndex"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get index"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapHandList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Access a list member by its position in the list.\n\n@param        Index   The zero-based list position index.\n@return       The Hand object at the specified index."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapHandList_Leftmost()
	{
		struct LeapHandList_eventLeftmost_Parms
		{
			ULeapHand* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapHandList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Leftmost"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapHandList_eventLeftmost_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapHandList_eventLeftmost_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapHand_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Hand List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("getLeftmost"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get leftmost"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapHandList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The member of the list that is farthest to the left within the standard Leap Motion frame of reference (i.e has the smallest Y coordinate).\n\n@return       The leftmost hand, or invalid if list is empty."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapHandList_Rightmost()
	{
		struct LeapHandList_eventRightmost_Parms
		{
			ULeapHand* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapHandList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Rightmost"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapHandList_eventRightmost_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapHandList_eventRightmost_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapHand_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Hand List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("getRightmost"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get rightmost"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapHandList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The member of the list that is farthest to the right within the standard Leap Motion frame of reference (i.e has the largest Y coordinate).\n\n@return       The rightmost hand, or invalid if list is empty."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapHandList_NoRegister()
	{
		return ULeapHandList::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapHandList()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapHandList::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapHandList_Frontmost());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapHandList_GetIndex());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapHandList_Leftmost());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapHandList_Rightmost());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PIndexHand = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PIndexHand"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PIndexHand, ULeapHandList), 0x0040000000000000, Z_Construct_UClass_ULeapHand_NoRegister());
				UProperty* NewProp_PRightmost = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PRightmost"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PRightmost, ULeapHandList), 0x0040000000000000, Z_Construct_UClass_ULeapHand_NoRegister());
				UProperty* NewProp_PLeftmost = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PLeftmost"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PLeftmost, ULeapHandList), 0x0040000000000000, Z_Construct_UClass_ULeapHand_NoRegister());
				UProperty* NewProp_PFrontmost = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PFrontmost"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PFrontmost, ULeapHandList), 0x0040000000000000, Z_Construct_UClass_ULeapHand_NoRegister());
				UProperty* NewProp_Count = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Count"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Count, ULeapHandList), 0x0010000000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsEmpty, ULeapHandList, bool);
				UProperty* NewProp_IsEmpty = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsEmpty"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsEmpty, ULeapHandList), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsEmpty, ULeapHandList), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapHandList_Frontmost(), "Frontmost"); // 2410772788
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapHandList_GetIndex(), "GetIndex"); // 3741317717
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapHandList_Leftmost(), "Leftmost"); // 2638778695
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapHandList_Rightmost(), "Rightmost"); // 1767131535
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapHandList.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapHandList.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The HandList class represents a list of Hand objects.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.HandList.html"));
				MetaData->SetValue(NewProp_PIndexHand, TEXT("ModuleRelativePath"), TEXT("Public/LeapHandList.h"));
				MetaData->SetValue(NewProp_PRightmost, TEXT("ModuleRelativePath"), TEXT("Public/LeapHandList.h"));
				MetaData->SetValue(NewProp_PLeftmost, TEXT("ModuleRelativePath"), TEXT("Public/LeapHandList.h"));
				MetaData->SetValue(NewProp_PFrontmost, TEXT("ModuleRelativePath"), TEXT("Public/LeapHandList.h"));
				MetaData->SetValue(NewProp_Count, TEXT("Category"), TEXT("Leap Hand List"));
				MetaData->SetValue(NewProp_Count, TEXT("ModuleRelativePath"), TEXT("Public/LeapHandList.h"));
				MetaData->SetValue(NewProp_Count, TEXT("ToolTip"), TEXT("The number of hands in this list."));
				MetaData->SetValue(NewProp_IsEmpty, TEXT("Category"), TEXT("Leap Hand List"));
				MetaData->SetValue(NewProp_IsEmpty, TEXT("ModuleRelativePath"), TEXT("Public/LeapHandList.h"));
				MetaData->SetValue(NewProp_IsEmpty, TEXT("ToolTip"), TEXT("Whether the list is empty."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapHandList(Z_Construct_UClass_ULeapHandList, &ULeapHandList::StaticClass, TEXT("ULeapHandList"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapHandList);
	UFunction* Z_Construct_UFunction_ULeapImage_Distortion()
	{
		struct LeapImage_eventDistortion_Parms
		{
			UTexture2D* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapImage();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Distortion"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapImage_eventDistortion_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapImage_eventDistortion_Parms), 0x0010000000000580, Z_Construct_UClass_UTexture2D_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Image"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Distortion"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("distortion"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Faster raw distortion (R=U, G=V), requires channel conversion, 32bit float per\nchannel texture will look odd if rendered raw.\n\n@return 128bit Distortion in raw UTexture2D format"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapImage_DistortionUE()
	{
		struct LeapImage_eventDistortionUE_Parms
		{
			UTexture2D* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapImage();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DistortionUE"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapImage_eventDistortionUE_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapImage_eventDistortionUE_Parms), 0x0010000000000580, Z_Construct_UClass_UTexture2D_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Image"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Distortion UE"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("distortion ue"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Visually correct distortion in UE format (R=U, G=1-V) at the cost of additional\nCPU time (roughly 1ms) in 8bit per channel format\n\n@return Distortion in converted UTexture2D format"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapImage_Rectify()
	{
		struct LeapImage_eventRectify_Parms
		{
			FVector uv;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapImage();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Rectify"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(LeapImage_eventRectify_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, LeapImage_eventRectify_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_uv = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("uv"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(uv, LeapImage_eventRectify_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Image"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("rectify"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("rectify"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Provides the corrected camera ray intercepting the specified point on the image."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapImage_Texture()
	{
		struct LeapImage_eventTexture_Parms
		{
			UTexture2D* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapImage();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Texture"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapImage_eventTexture_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapImage_eventTexture_Parms), 0x0010000000000580, Z_Construct_UClass_UTexture2D_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Image"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("Texture"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get texture"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns a UTexture2D reference that contains the latest raw Leap Image data in\nUE format. This can be optionally gamma corrected.\n\n@return Image in converted UTexture2D format"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapImage_Warp()
	{
		struct LeapImage_eventWarp_Parms
		{
			FVector XY;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapImage();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Warp"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(LeapImage_eventWarp_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, LeapImage_eventWarp_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_XY = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("XY"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(XY, LeapImage_eventWarp_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Image"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("warp"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("warp"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Provides the point in the image corresponding to a ray projecting from the camera.\nGiven a ray projected from the camera in the specified direction, warp() corrects\nfor camera distortion and returns the corresponding pixel coordinates in the image.\nThe ray direction is specified in relationship to the camera. The first vector element\ncorresponds to the ?horizontal? view angle; the second corresponds to the ?vertical?\nview angle.\n\n@param        XY      A Vector containing the ray direction.\n@return       A Vector containing the pixel coordinates [x, y, 0] (with z always zero)."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapImage_NoRegister()
	{
		return ULeapImage::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapImage()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapImage::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapImage_Distortion());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapImage_DistortionUE());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapImage_Rectify());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapImage_Texture());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapImage_Warp());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PDistortionPointer = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PDistortionPointer"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PDistortionPointer, ULeapImage), 0x0040000000000000, Z_Construct_UClass_UTexture2D_NoRegister());
				UProperty* NewProp_PImagePointer = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PImagePointer"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PImagePointer, ULeapImage), 0x0040000000000000, Z_Construct_UClass_UTexture2D_NoRegister());
				UProperty* NewProp_Width = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Width"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Width, ULeapImage), 0x0010000000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(UseGammaCorrection, ULeapImage, bool);
				UProperty* NewProp_UseGammaCorrection = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("UseGammaCorrection"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(UseGammaCorrection, ULeapImage), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(UseGammaCorrection, ULeapImage), sizeof(bool), true);
				UProperty* NewProp_RayScaleY = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RayScaleY"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(RayScaleY, ULeapImage), 0x0010000000000015);
				UProperty* NewProp_RayScaleX = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RayScaleX"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(RayScaleX, ULeapImage), 0x0010000000000015);
				UProperty* NewProp_RayOffsetY = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RayOffsetY"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(RayOffsetY, ULeapImage), 0x0010000000000015);
				UProperty* NewProp_RayOffsetX = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("RayOffsetX"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(RayOffsetX, ULeapImage), 0x0010000000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsValid, ULeapImage, bool);
				UProperty* NewProp_IsValid = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsValid"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsValid, ULeapImage), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsValid, ULeapImage), sizeof(bool), true);
				UProperty* NewProp_Id = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Id"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Id, ULeapImage), 0x0010000000000015);
				UProperty* NewProp_Height = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Height"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Height, ULeapImage), 0x0010000000000015);
				UProperty* NewProp_DistortionWidth = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DistortionWidth"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(DistortionWidth, ULeapImage), 0x0010000000000015);
				UProperty* NewProp_DistortionHeight = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("DistortionHeight"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(DistortionHeight, ULeapImage), 0x0010000000000015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapImage_Distortion(), "Distortion"); // 3661934605
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapImage_DistortionUE(), "DistortionUE"); // 1134516331
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapImage_Rectify(), "Rectify"); // 2878265878
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapImage_Texture(), "Texture"); // 3189426048
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapImage_Warp(), "Warp"); // 2975350583
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapImage.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The Image class represents a single image from one of the Leap Motion cameras.\nYou can obtain the images from your frame object or from listening to raw image events in LeapEventInterface\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.Image.html"));
				MetaData->SetValue(NewProp_PDistortionPointer, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
				MetaData->SetValue(NewProp_PImagePointer, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
				MetaData->SetValue(NewProp_Width, TEXT("Category"), TEXT("Leap Image"));
				MetaData->SetValue(NewProp_Width, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
				MetaData->SetValue(NewProp_Width, TEXT("ToolTip"), TEXT("The image width."));
				MetaData->SetValue(NewProp_UseGammaCorrection, TEXT("Category"), TEXT("Leap Image"));
				MetaData->SetValue(NewProp_UseGammaCorrection, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
				MetaData->SetValue(NewProp_UseGammaCorrection, TEXT("ToolTip"), TEXT("Whether this image should apply gamma correction when fetching the texture."));
				MetaData->SetValue(NewProp_RayScaleY, TEXT("Category"), TEXT("Leap Image"));
				MetaData->SetValue(NewProp_RayScaleY, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
				MetaData->SetValue(NewProp_RayScaleY, TEXT("ToolTip"), TEXT("The vertical ray scale factor."));
				MetaData->SetValue(NewProp_RayScaleX, TEXT("Category"), TEXT("Leap Image"));
				MetaData->SetValue(NewProp_RayScaleX, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
				MetaData->SetValue(NewProp_RayScaleX, TEXT("ToolTip"), TEXT("The horizontal ray scale factor."));
				MetaData->SetValue(NewProp_RayOffsetY, TEXT("Category"), TEXT("Leap Image"));
				MetaData->SetValue(NewProp_RayOffsetY, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
				MetaData->SetValue(NewProp_RayOffsetY, TEXT("ToolTip"), TEXT("The vertical ray offset."));
				MetaData->SetValue(NewProp_RayOffsetX, TEXT("Category"), TEXT("Leap Image"));
				MetaData->SetValue(NewProp_RayOffsetX, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
				MetaData->SetValue(NewProp_RayOffsetX, TEXT("ToolTip"), TEXT("The horizontal ray offset."));
				MetaData->SetValue(NewProp_IsValid, TEXT("Category"), TEXT("Leap Image"));
				MetaData->SetValue(NewProp_IsValid, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
				MetaData->SetValue(NewProp_IsValid, TEXT("ToolTip"), TEXT("Reports whether this Image instance contains valid data."));
				MetaData->SetValue(NewProp_Id, TEXT("Category"), TEXT("Leap Image"));
				MetaData->SetValue(NewProp_Id, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
				MetaData->SetValue(NewProp_Id, TEXT("ToolTip"), TEXT("The image ID. Images with ID of 0 are from the left camera;\nthose with an ID of 1 are from the right camera (with the device in its standard operating\nposition with the green LED facing the operator)."));
				MetaData->SetValue(NewProp_Height, TEXT("Category"), TEXT("Leap Image"));
				MetaData->SetValue(NewProp_Height, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
				MetaData->SetValue(NewProp_Height, TEXT("ToolTip"), TEXT("The image height."));
				MetaData->SetValue(NewProp_DistortionWidth, TEXT("Category"), TEXT("Leap Image"));
				MetaData->SetValue(NewProp_DistortionWidth, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
				MetaData->SetValue(NewProp_DistortionWidth, TEXT("ToolTip"), TEXT("The stride of the distortion map."));
				MetaData->SetValue(NewProp_DistortionHeight, TEXT("Category"), TEXT("Leap Image"));
				MetaData->SetValue(NewProp_DistortionHeight, TEXT("ModuleRelativePath"), TEXT("Public/LeapImage.h"));
				MetaData->SetValue(NewProp_DistortionHeight, TEXT("ToolTip"), TEXT("The distortion map height."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapImage(Z_Construct_UClass_ULeapImage, &ULeapImage::StaticClass, TEXT("ULeapImage"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapImage);
	UFunction* Z_Construct_UFunction_ULeapImageList_GetIndex()
	{
		struct LeapImageList_eventGetIndex_Parms
		{
			int32 Index;
			ULeapImage* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapImageList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapImageList_eventGetIndex_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapImageList_eventGetIndex_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapImage_NoRegister());
			UProperty* NewProp_Index = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Index"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Index, LeapImageList_eventGetIndex_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Image List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("getIndex"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get index"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapImageList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Access a list member by its position in the list.\n\n@param        Index   The zero-based list position index.\n@return       The Image object at the specified index."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapImageList_NoRegister()
	{
		return ULeapImageList::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapImageList()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapImageList::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapImageList_GetIndex());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PIndexImage2 = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PIndexImage2"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PIndexImage2, ULeapImageList), 0x0040000000000000, Z_Construct_UClass_ULeapImage_NoRegister());
				UProperty* NewProp_PIndexImage1 = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PIndexImage1"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PIndexImage1, ULeapImageList), 0x0040000000000000, Z_Construct_UClass_ULeapImage_NoRegister());
				UProperty* NewProp_Count = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Count"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Count, ULeapImageList), 0x0010000000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsEmpty, ULeapImageList, bool);
				UProperty* NewProp_IsEmpty = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsEmpty"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsEmpty, ULeapImageList), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsEmpty, ULeapImageList), sizeof(bool), true);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapImageList_GetIndex(), "GetIndex"); // 1722259371
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapImageList.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapImageList.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The ImageList class represents a list of Image objects.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.ImageList.html"));
				MetaData->SetValue(NewProp_PIndexImage2, TEXT("ModuleRelativePath"), TEXT("Public/LeapImageList.h"));
				MetaData->SetValue(NewProp_PIndexImage1, TEXT("ModuleRelativePath"), TEXT("Public/LeapImageList.h"));
				MetaData->SetValue(NewProp_Count, TEXT("Category"), TEXT("Leap Image List"));
				MetaData->SetValue(NewProp_Count, TEXT("ModuleRelativePath"), TEXT("Public/LeapImageList.h"));
				MetaData->SetValue(NewProp_Count, TEXT("ToolTip"), TEXT("The number of images in this list."));
				MetaData->SetValue(NewProp_IsEmpty, TEXT("Category"), TEXT("Leap Image List"));
				MetaData->SetValue(NewProp_IsEmpty, TEXT("ModuleRelativePath"), TEXT("Public/LeapImageList.h"));
				MetaData->SetValue(NewProp_IsEmpty, TEXT("ToolTip"), TEXT("Whether the list is empty."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapImageList(Z_Construct_UClass_ULeapImageList, &ULeapImageList::StaticClass, TEXT("ULeapImageList"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapImageList);
	UFunction* Z_Construct_UFunction_ULeapInteractionBox_DenormalizePoint()
	{
		struct LeapInteractionBox_eventDenormalizePoint_Parms
		{
			FVector Position;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapInteractionBox();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("DenormalizePoint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(LeapInteractionBox_eventDenormalizePoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, LeapInteractionBox_eventDenormalizePoint_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_Position = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Position"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Position, LeapInteractionBox_eventDenormalizePoint_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interaction Box"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("DenormalizePoint"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("normalize point"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapInteractionBox.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Converts a position defined by normalized InteractionBox coordinates into\ndevice coordinates in centimeters."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapInteractionBox_NormalizePoint()
	{
		struct LeapInteractionBox_eventNormalizePoint_Parms
		{
			FVector Position;
			bool Clamp;
			FVector ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapInteractionBox();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("NormalizePoint"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54820401, 65535, sizeof(LeapInteractionBox_eventNormalizePoint_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, LeapInteractionBox_eventNormalizePoint_Parms), 0x0010000000000580, Z_Construct_UScriptStruct_FVector());
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(Clamp, LeapInteractionBox_eventNormalizePoint_Parms, bool);
			UProperty* NewProp_Clamp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Clamp"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(Clamp, LeapInteractionBox_eventNormalizePoint_Parms), 0x0010000000000080, CPP_BOOL_PROPERTY_BITMASK(Clamp, LeapInteractionBox_eventNormalizePoint_Parms), sizeof(bool), true);
			UProperty* NewProp_Position = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Position"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Position, LeapInteractionBox_eventNormalizePoint_Parms), 0x0010000000000080, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Interaction Box"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("CPP_Default_Clamp"), TEXT("true"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("normalizePoint"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("normalize point"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapInteractionBox.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Normalizes the coordinates of a point using the interaction box.\n\n@param        Position        The input position in device coordinates.\n@param        Clamp           Whether or not to limit the output value to the range [0,1] when the input position is outside the InteractionBox. Defaults to true.\n@return       The normalized position."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapInteractionBox_NoRegister()
	{
		return ULeapInteractionBox::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapInteractionBox()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapInteractionBox::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapInteractionBox_DenormalizePoint());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapInteractionBox_NormalizePoint());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Width = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Width"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Width, ULeapInteractionBox), 0x0010000000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsValid, ULeapInteractionBox, bool);
				UProperty* NewProp_IsValid = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsValid"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsValid, ULeapInteractionBox), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsValid, ULeapInteractionBox), sizeof(bool), true);
				UProperty* NewProp_Height = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Height"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Height, ULeapInteractionBox), 0x0010000000000015);
				UProperty* NewProp_Depth = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Depth"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Depth, ULeapInteractionBox), 0x0010000000000015);
				UProperty* NewProp_Center = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Center"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Center, ULeapInteractionBox), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapInteractionBox_DenormalizePoint(), "DenormalizePoint"); // 3242050813
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapInteractionBox_NormalizePoint(), "NormalizePoint"); // 3811226718
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapInteractionBox.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapInteractionBox.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The InteractionBox class represents a box-shaped region completely within the\nfield of view of the Leap Motion controller. The interaction box is an axis-aligned\nrectangular prism and provides normalized coordinates for hands, fingers, and tools\nwithin this box.\n\nThe InteractionBox class can make it easier to map positions in the Leap Motion coordinate\nsystem to 2D or 3D coordinate systems used for application drawing.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.InteractionBox.html"));
				MetaData->SetValue(NewProp_Width, TEXT("Category"), TEXT("Leap Interaction Box"));
				MetaData->SetValue(NewProp_Width, TEXT("ModuleRelativePath"), TEXT("Public/LeapInteractionBox.h"));
				MetaData->SetValue(NewProp_Width, TEXT("ToolTip"), TEXT("The width of the InteractionBox in centimeters, measured along the y-axis."));
				MetaData->SetValue(NewProp_IsValid, TEXT("Category"), TEXT("Leap Interaction Box"));
				MetaData->SetValue(NewProp_IsValid, TEXT("ModuleRelativePath"), TEXT("Public/LeapInteractionBox.h"));
				MetaData->SetValue(NewProp_IsValid, TEXT("ToolTip"), TEXT("Reports whether this is a valid InteractionBox object."));
				MetaData->SetValue(NewProp_Height, TEXT("Category"), TEXT("Leap Interaction Box"));
				MetaData->SetValue(NewProp_Height, TEXT("ModuleRelativePath"), TEXT("Public/LeapInteractionBox.h"));
				MetaData->SetValue(NewProp_Height, TEXT("ToolTip"), TEXT("The height of the InteractionBox in centimeters, measured along the z-axis."));
				MetaData->SetValue(NewProp_Depth, TEXT("Category"), TEXT("Leap Interaction Box"));
				MetaData->SetValue(NewProp_Depth, TEXT("ModuleRelativePath"), TEXT("Public/LeapInteractionBox.h"));
				MetaData->SetValue(NewProp_Depth, TEXT("ToolTip"), TEXT("The depth of the InteractionBox in centimeters, measured along the x-axis."));
				MetaData->SetValue(NewProp_Center, TEXT("Category"), TEXT("Leap Interaction Box"));
				MetaData->SetValue(NewProp_Center, TEXT("ModuleRelativePath"), TEXT("Public/LeapInteractionBox.h"));
				MetaData->SetValue(NewProp_Center, TEXT("ToolTip"), TEXT("The center of the InteractionBox in device coordinates (centimeters)."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapInteractionBox(Z_Construct_UClass_ULeapInteractionBox, &ULeapInteractionBox::StaticClass, TEXT("ULeapInteractionBox"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapInteractionBox);
	UFunction* Z_Construct_UFunction_ULeapPointable_Different()
	{
		struct LeapPointable_eventDifferent_Parms
		{
			const ULeapPointable* Other;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapPointable();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Different"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(LeapPointable_eventDifferent_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapPointable_eventDifferent_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapPointable_eventDifferent_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapPointable_eventDifferent_Parms), sizeof(bool), true);
			UProperty* NewProp_Other = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Other"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Other, LeapPointable_eventDifferent_Parms), 0x0010000000000082, Z_Construct_UClass_ULeapPointable_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Pointable"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT("!="));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("different"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("different"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Compare Pointable object inequality.\n\n@param        Other   pointable to compare to.\n@return       True if different."));
			MetaData->SetValue(NewProp_Other, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapPointable_Equal()
	{
		struct LeapPointable_eventEqual_Parms
		{
			const ULeapPointable* Other;
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapPointable();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Equal"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(LeapPointable_eventEqual_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapPointable_eventEqual_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapPointable_eventEqual_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapPointable_eventEqual_Parms), sizeof(bool), true);
			UProperty* NewProp_Other = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Other"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Other, LeapPointable_eventEqual_Parms), 0x0010000000000082, Z_Construct_UClass_ULeapPointable_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Pointable"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT("=="));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("equal"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("equal"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Compare Pointable object equality.\n\n@param        Other   pointable to compare to.\n@return       True if equal."));
			MetaData->SetValue(NewProp_Other, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapPointable_Frame()
	{
		struct LeapPointable_eventFrame_Parms
		{
			ULeapFrame* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapPointable();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Frame"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(LeapPointable_eventFrame_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapPointable_eventFrame_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapFrame_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Pointable"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("frame"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("frame"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The Frame associated with this Pointable object.\n\n@return       The associated Frame object, if available; otherwise, an invalid Frame object is returned."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapPointable_Hand()
	{
		struct LeapPointable_eventHand_Parms
		{
			ULeapHand* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapPointable();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Hand"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020400, 65535, sizeof(LeapPointable_eventHand_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapPointable_eventHand_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapHand_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Pointable"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("hand"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("hand"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The Hand associated with a finger.\n\n@return       The associated Hand object, if available; otherwise, an invalid Hand object is returned."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapPointable_NoRegister()
	{
		return ULeapPointable::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapPointable()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapPointable::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapPointable_Different());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapPointable_Equal());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapPointable_Frame());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapPointable_Hand());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PHand = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PHand"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PHand, ULeapPointable), 0x0040000000000000, Z_Construct_UClass_ULeapHand_NoRegister());
				UProperty* NewProp_PFrame = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PFrame"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PFrame, ULeapPointable), 0x0040000000000000, Z_Construct_UClass_ULeapFrame_NoRegister());
				UProperty* NewProp_Width = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Width"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Width, ULeapPointable), 0x0010000000000015);
				UProperty* NewProp_TouchZone = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TouchZone"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(TouchZone, ULeapPointable), 0x0010000000000015, Z_Construct_UEnum_LeapMotion_LeapZone());
				UProperty* NewProp_TouchDistance = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TouchDistance"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TouchDistance, ULeapPointable), 0x0010000000000015);
				UProperty* NewProp_TipVelocity = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TipVelocity"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(TipVelocity, ULeapPointable), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_TipPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TipPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(TipPosition, ULeapPointable), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_TimeVisible = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("TimeVisible"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(TimeVisible, ULeapPointable), 0x0010000000000015);
				UProperty* NewProp_StabilizedTipPosition = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("StabilizedTipPosition"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(StabilizedTipPosition, ULeapPointable), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_Length = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Length"), RF_Public|RF_Transient|RF_MarkAsNative) UFloatProperty(CPP_PROPERTY_BASE(Length, ULeapPointable), 0x0010000000000015);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsValid, ULeapPointable, bool);
				UProperty* NewProp_IsValid = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsValid"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsValid, ULeapPointable), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsValid, ULeapPointable), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsTool, ULeapPointable, bool);
				UProperty* NewProp_IsTool = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsTool"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsTool, ULeapPointable), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsTool, ULeapPointable), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsFinger, ULeapPointable, bool);
				UProperty* NewProp_IsFinger = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsFinger"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsFinger, ULeapPointable), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsFinger, ULeapPointable), sizeof(bool), true);
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsExtended, ULeapPointable, bool);
				UProperty* NewProp_IsExtended = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsExtended"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsExtended, ULeapPointable), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsExtended, ULeapPointable), sizeof(bool), true);
				UProperty* NewProp_Id = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Id"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Id, ULeapPointable), 0x0010000000000015);
				UProperty* NewProp_Direction = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Direction"), RF_Public|RF_Transient|RF_MarkAsNative) UStructProperty(CPP_PROPERTY_BASE(Direction, ULeapPointable), 0x0010000000000015, Z_Construct_UScriptStruct_FVector());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapPointable_Different(), "Different"); // 2252935415
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapPointable_Equal(), "Equal"); // 2057170149
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapPointable_Frame(), "Frame"); // 3382335585
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapPointable_Hand(), "Hand"); // 1854514564
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapPointable.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The Pointable class reports the physical characteristics of a detected finger or tool.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.Pointable.html"));
				MetaData->SetValue(NewProp_PHand, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(NewProp_PFrame, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(NewProp_Width, TEXT("Category"), TEXT("Leap Pointable"));
				MetaData->SetValue(NewProp_Width, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(NewProp_Width, TEXT("ToolTip"), TEXT("The estimated width of the finger or tool in centimeters."));
				MetaData->SetValue(NewProp_TouchZone, TEXT("Category"), TEXT("Leap Pointable"));
				MetaData->SetValue(NewProp_TouchZone, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(NewProp_TouchZone, TEXT("ToolTip"), TEXT("The current touch zone of this Pointable object."));
				MetaData->SetValue(NewProp_TouchDistance, TEXT("Category"), TEXT("Leap Pointable"));
				MetaData->SetValue(NewProp_TouchDistance, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(NewProp_TouchDistance, TEXT("ToolTip"), TEXT("A value proportional to the distance between this Pointable object and the\nadaptive touch plane."));
				MetaData->SetValue(NewProp_TipVelocity, TEXT("Category"), TEXT("Leap Pointable"));
				MetaData->SetValue(NewProp_TipVelocity, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(NewProp_TipVelocity, TEXT("ToolTip"), TEXT("The rate of change of the tip position in centimeters/second."));
				MetaData->SetValue(NewProp_TipPosition, TEXT("Category"), TEXT("Leap Pointable"));
				MetaData->SetValue(NewProp_TipPosition, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(NewProp_TipPosition, TEXT("ToolTip"), TEXT("The tip position in centimeters from the Leap Motion origin."));
				MetaData->SetValue(NewProp_TimeVisible, TEXT("Category"), TEXT("Leap Pointable"));
				MetaData->SetValue(NewProp_TimeVisible, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(NewProp_TimeVisible, TEXT("ToolTip"), TEXT("The duration of time this Pointable has been visible to the Leap Motion Controller."));
				MetaData->SetValue(NewProp_StabilizedTipPosition, TEXT("Category"), TEXT("Leap Pointable"));
				MetaData->SetValue(NewProp_StabilizedTipPosition, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(NewProp_StabilizedTipPosition, TEXT("ToolTip"), TEXT("The stabilized tip position of this Pointable."));
				MetaData->SetValue(NewProp_Length, TEXT("Category"), TEXT("Leap Pointable"));
				MetaData->SetValue(NewProp_Length, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(NewProp_Length, TEXT("ToolTip"), TEXT("The estimated length of the finger or tool in centimeters."));
				MetaData->SetValue(NewProp_IsValid, TEXT("Category"), TEXT("Leap Pointable"));
				MetaData->SetValue(NewProp_IsValid, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(NewProp_IsValid, TEXT("ToolTip"), TEXT("Reports whether this is a valid Pointable object."));
				MetaData->SetValue(NewProp_IsTool, TEXT("Category"), TEXT("Leap Pointable"));
				MetaData->SetValue(NewProp_IsTool, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(NewProp_IsTool, TEXT("ToolTip"), TEXT("Whether or not this Pointable is classified as a tool."));
				MetaData->SetValue(NewProp_IsFinger, TEXT("Category"), TEXT("Leap Pointable"));
				MetaData->SetValue(NewProp_IsFinger, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(NewProp_IsFinger, TEXT("ToolTip"), TEXT("Whether or not this Pointable is classified as a finger."));
				MetaData->SetValue(NewProp_IsExtended, TEXT("Category"), TEXT("Leap Pointable"));
				MetaData->SetValue(NewProp_IsExtended, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(NewProp_IsExtended, TEXT("ToolTip"), TEXT("Whether or not this Pointable is in an extended posture."));
				MetaData->SetValue(NewProp_Id, TEXT("Category"), TEXT("Leap Pointable"));
				MetaData->SetValue(NewProp_Id, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(NewProp_Id, TEXT("ToolTip"), TEXT("A unique ID assigned to this Pointable object, whose value remains the same\nacross consecutive frames while the tracked finger or tool remains visible."));
				MetaData->SetValue(NewProp_Direction, TEXT("Category"), TEXT("Leap Pointable"));
				MetaData->SetValue(NewProp_Direction, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointable.h"));
				MetaData->SetValue(NewProp_Direction, TEXT("ToolTip"), TEXT("The direction in which this finger or tool is pointing. The direction is\nexpressed as a unit vector pointing in the same direction as the tip."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapPointable(Z_Construct_UClass_ULeapPointable, &ULeapPointable::StaticClass, TEXT("ULeapPointable"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapPointable);
	UFunction* Z_Construct_UFunction_ULeapFinger_Bone()
	{
		struct LeapFinger_eventBone_Parms
		{
			TEnumAsByte<LeapBoneType> Type;
			ULeapBone* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapFinger();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Bone"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapFinger_eventBone_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapFinger_eventBone_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapBone_NoRegister());
			UProperty* NewProp_Type = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Type"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Type, LeapFinger_eventBone_Parms), 0x0010000000000080, Z_Construct_UEnum_LeapMotion_LeapBoneType());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Finger"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapFinger.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The bone at a given bone type index on this finger.\n\n@param        Type value from the LeapBoneType enumeration identifying the bone of interest.\n@return       The Bone that has the specified bone type."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapFinger_NoRegister()
	{
		return ULeapFinger::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapFinger()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ULeapPointable();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapFinger::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapFinger_Bone());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_Type = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Type"), RF_Public|RF_Transient|RF_MarkAsNative) UByteProperty(CPP_PROPERTY_BASE(Type, ULeapFinger), 0x0010000000000015, Z_Construct_UEnum_LeapMotion_LeapFingerType());
				UProperty* NewProp_Distal = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Distal"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Distal, ULeapFinger), 0x0010000000000015, Z_Construct_UClass_ULeapBone_NoRegister());
				UProperty* NewProp_Intermediate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Intermediate"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Intermediate, ULeapFinger), 0x0010000000000015, Z_Construct_UClass_ULeapBone_NoRegister());
				UProperty* NewProp_Proximal = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Proximal"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Proximal, ULeapFinger), 0x0010000000000015, Z_Construct_UClass_ULeapBone_NoRegister());
				UProperty* NewProp_Metacarpal = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Metacarpal"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(Metacarpal, ULeapFinger), 0x0010000000000015, Z_Construct_UClass_ULeapBone_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapFinger_Bone(), "Bone"); // 3655784121
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapFinger.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapFinger.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The Finger class represents a tracked finger.\n\nFingers are Pointable objects that the Leap Motion software has classified as a\nfinger. Get valid Finger objects from a Frame or a Hand object.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.Finger.html"));
				MetaData->SetValue(NewProp_Type, TEXT("Category"), TEXT("Leap Finger"));
				MetaData->SetValue(NewProp_Type, TEXT("ModuleRelativePath"), TEXT("Public/LeapFinger.h"));
				MetaData->SetValue(NewProp_Type, TEXT("ToolTip"), TEXT("Type of finger as enum (see LeapFingerType enum)"));
				MetaData->SetValue(NewProp_Distal, TEXT("Category"), TEXT("Leap Finger"));
				MetaData->SetValue(NewProp_Distal, TEXT("ModuleRelativePath"), TEXT("Public/LeapFinger.h"));
				MetaData->SetValue(NewProp_Distal, TEXT("ToolTip"), TEXT("The Distal bone of this finger."));
				MetaData->SetValue(NewProp_Intermediate, TEXT("Category"), TEXT("Leap Finger"));
				MetaData->SetValue(NewProp_Intermediate, TEXT("ModuleRelativePath"), TEXT("Public/LeapFinger.h"));
				MetaData->SetValue(NewProp_Intermediate, TEXT("ToolTip"), TEXT("The Intermediate bone of this finger."));
				MetaData->SetValue(NewProp_Proximal, TEXT("Category"), TEXT("Leap Finger"));
				MetaData->SetValue(NewProp_Proximal, TEXT("ModuleRelativePath"), TEXT("Public/LeapFinger.h"));
				MetaData->SetValue(NewProp_Proximal, TEXT("ToolTip"), TEXT("The Proximal bone of this finger."));
				MetaData->SetValue(NewProp_Metacarpal, TEXT("Category"), TEXT("Leap Finger"));
				MetaData->SetValue(NewProp_Metacarpal, TEXT("ModuleRelativePath"), TEXT("Public/LeapFinger.h"));
				MetaData->SetValue(NewProp_Metacarpal, TEXT("ToolTip"), TEXT("The Metacarpal bone of this finger."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapFinger(Z_Construct_UClass_ULeapFinger, &ULeapFinger::StaticClass, TEXT("ULeapFinger"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapFinger);
	UClass* Z_Construct_UClass_ULeapTool_NoRegister()
	{
		return ULeapTool::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapTool()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_ULeapPointable();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapTool::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;


				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapTool.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapTool.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The Tool class represents a tracked tool.\nTools are Pointable objects that the Leap Motion software has classified as a tool.\nGet valid Tool objects from a Frame object.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.Tool.html"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapTool(Z_Construct_UClass_ULeapTool, &ULeapTool::StaticClass, TEXT("ULeapTool"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapTool);
	UFunction* Z_Construct_UFunction_ULeapPointableList_Append()
	{
		struct LeapPointableList_eventAppend_Parms
		{
			ULeapPointableList* List;
			ULeapPointableList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapPointableList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Append"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapPointableList_eventAppend_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapPointableList_eventAppend_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapPointableList_NoRegister());
			UProperty* NewProp_List = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("List"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(List, LeapPointableList_eventAppend_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapPointableList_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Pointable List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("append"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("append"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Appends the members of the specified PointableList to this PointableList.\n\n@param        List    A PointableList object containing Pointable objects to append to the end of this PointableList.\n@return       A PointableList object with the current and appended list"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapPointableList_AppendFingers()
	{
		struct LeapPointableList_eventAppendFingers_Parms
		{
			ULeapFingerList* List;
			ULeapPointableList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapPointableList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AppendFingers"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapPointableList_eventAppendFingers_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapPointableList_eventAppendFingers_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapPointableList_NoRegister());
			UProperty* NewProp_List = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("List"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(List, LeapPointableList_eventAppendFingers_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapFingerList_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Pointable List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("appendFingers"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("append"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Appends the members of the specified FingerList to this PointableList.\n\n@param        List    A FingerList object containing Finger objects to append to the end of this PointableList.\n@return       A PointableList object with the current and appended list"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapPointableList_AppendTools()
	{
		struct LeapPointableList_eventAppendTools_Parms
		{
			ULeapToolList* List;
			ULeapPointableList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapPointableList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AppendTools"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapPointableList_eventAppendTools_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapPointableList_eventAppendTools_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapPointableList_NoRegister());
			UProperty* NewProp_List = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("List"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(List, LeapPointableList_eventAppendTools_Parms), 0x0010000000000080, Z_Construct_UClass_ULeapToolList_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Pointable List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("appendTools"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("append"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Appends the members of the specified ToolList to this PointableList.\n\n@param        List    A ToolList object containing Tool objects to append to the end of this PointableList.\n@return       A PointableList object with the current and appended list"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapPointableList_Extended()
	{
		struct LeapPointableList_eventExtended_Parms
		{
			ULeapPointableList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapPointableList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Extended"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapPointableList_eventExtended_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapPointableList_eventExtended_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapPointableList_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Pointable List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("extended"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("extended"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns a new list containing those members of the current list that are extended.\n\n@return       The list of tools and extended fingers from the current list."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapPointableList_Frontmost()
	{
		struct LeapPointableList_eventFrontmost_Parms
		{
			ULeapPointable* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapPointableList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Frontmost"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapPointableList_eventFrontmost_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapPointableList_eventFrontmost_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapPointable_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Pointable List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("frontmost"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("frontmost"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The member of the list that is farthest to the front within the standard Leap Motion\nframe of reference (i.e has the largest X coordinate).\n\n@return       The frontmost pointable, or invalid if list is empty."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapPointableList_GetPointableByIndex()
	{
		struct LeapPointableList_eventGetPointableByIndex_Parms
		{
			int32 Index;
			ULeapPointable* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapPointableList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPointableByIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapPointableList_eventGetPointableByIndex_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapPointableList_eventGetPointableByIndex_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapPointable_NoRegister());
			UProperty* NewProp_Index = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Index"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Index, LeapPointableList_eventGetPointableByIndex_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Pointable List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT("[]"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("getPointableByIndex"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get pointable by index"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Access a list member by its position in the list.\n\n@param        Index   position in the list.\n@return The Pointable object at the specified index."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapPointableList_Leftmost()
	{
		struct LeapPointableList_eventLeftmost_Parms
		{
			ULeapPointable* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapPointableList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Leftmost"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapPointableList_eventLeftmost_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapPointableList_eventLeftmost_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapPointable_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Pointable List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("leftmost"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("leftmost"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The member of the list that is farthest to the left within the standard Leap Motion\nframe of reference (i.e has the smallest Y coordinate).\n\n@return       The leftmost pointable, or invalid if list is empty."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapPointableList_Rightmost()
	{
		struct LeapPointableList_eventRightmost_Parms
		{
			ULeapPointable* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapPointableList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Rightmost"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapPointableList_eventRightmost_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapPointableList_eventRightmost_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapPointable_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Pointable List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("rightmost"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("rightmost"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The member of the list that is farthest to the right within the standard Leap Motion\nframe of reference (i.e has the largest Y coordinate).\n\n@return       The rightmost pointable, or invalid if list is empty."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapPointableList_NoRegister()
	{
		return ULeapPointableList::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapPointableList()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapPointableList::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapPointableList_Append());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapPointableList_AppendFingers());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapPointableList_AppendTools());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapPointableList_Extended());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapPointableList_Frontmost());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapPointableList_GetPointableByIndex());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapPointableList_Leftmost());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapPointableList_Rightmost());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PExtendedList = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PExtendedList"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PExtendedList, ULeapPointableList), 0x0040000000000000, Z_Construct_UClass_ULeapPointableList_NoRegister());
				UProperty* NewProp_PAppendedList = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PAppendedList"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PAppendedList, ULeapPointableList), 0x0040000000000000, Z_Construct_UClass_ULeapPointableList_NoRegister());
				UProperty* NewProp_PPointableByIndex = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PPointableByIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PPointableByIndex, ULeapPointableList), 0x0040000000000000, Z_Construct_UClass_ULeapPointable_NoRegister());
				UProperty* NewProp_PFrontmost = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PFrontmost"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PFrontmost, ULeapPointableList), 0x0040000000000000, Z_Construct_UClass_ULeapPointable_NoRegister());
				UProperty* NewProp_PRightmost = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PRightmost"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PRightmost, ULeapPointableList), 0x0040000000000000, Z_Construct_UClass_ULeapPointable_NoRegister());
				UProperty* NewProp_PLeftmost = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PLeftmost"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PLeftmost, ULeapPointableList), 0x0040000000000000, Z_Construct_UClass_ULeapPointable_NoRegister());
				CPP_BOOL_PROPERTY_BITMASK_STRUCT(IsEmpty, ULeapPointableList, bool);
				UProperty* NewProp_IsEmpty = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("IsEmpty"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(IsEmpty, ULeapPointableList), 0x0010000000000015, CPP_BOOL_PROPERTY_BITMASK(IsEmpty, ULeapPointableList), sizeof(bool), true);
				UProperty* NewProp_Count = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("Count"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Count, ULeapPointableList), 0x0010000000000015);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapPointableList_Append(), "Append"); // 670018056
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapPointableList_AppendFingers(), "AppendFingers"); // 4144310420
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapPointableList_AppendTools(), "AppendTools"); // 2816099022
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapPointableList_Extended(), "Extended"); // 3606334903
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapPointableList_Frontmost(), "Frontmost"); // 3536388913
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapPointableList_GetPointableByIndex(), "GetPointableByIndex"); // 830199753
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapPointableList_Leftmost(), "Leftmost"); // 286723473
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapPointableList_Rightmost(), "Rightmost"); // 1769943115
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapPointableList.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The PointableList class represents a list of Pointable objects.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.PointableList.html"));
				MetaData->SetValue(NewProp_PExtendedList, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
				MetaData->SetValue(NewProp_PAppendedList, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
				MetaData->SetValue(NewProp_PPointableByIndex, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
				MetaData->SetValue(NewProp_PFrontmost, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
				MetaData->SetValue(NewProp_PRightmost, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
				MetaData->SetValue(NewProp_PLeftmost, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
				MetaData->SetValue(NewProp_IsEmpty, TEXT("Category"), TEXT("Leap Pointable List"));
				MetaData->SetValue(NewProp_IsEmpty, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
				MetaData->SetValue(NewProp_IsEmpty, TEXT("ToolTip"), TEXT("Reports whether the list is empty."));
				MetaData->SetValue(NewProp_Count, TEXT("Category"), TEXT("Leap Pointable List"));
				MetaData->SetValue(NewProp_Count, TEXT("ModuleRelativePath"), TEXT("Public/LeapPointableList.h"));
				MetaData->SetValue(NewProp_Count, TEXT("ToolTip"), TEXT("The number of pointable entities in this list."));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapPointableList(Z_Construct_UClass_ULeapPointableList, &ULeapPointableList::StaticClass, TEXT("ULeapPointableList"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapPointableList);
	UFunction* Z_Construct_UFunction_ULeapToolList_Append()
	{
		struct LeapToolList_eventAppend_Parms
		{
			const ULeapToolList* List;
			ULeapToolList* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapToolList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Append"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapToolList_eventAppend_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapToolList_eventAppend_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapToolList_NoRegister());
			UProperty* NewProp_List = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("List"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(List, LeapToolList_eventAppend_Parms), 0x0010000000000082, Z_Construct_UClass_ULeapToolList_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Tool List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("append"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("append"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapToolList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Appends the members of the specified ToolList to this ToolList.\n\n@param        List    A ToolList object containing Tool objects to append to the end of this ToolList.\n@return       A ToolList object with the current and appended list"));
			MetaData->SetValue(NewProp_List, TEXT("NativeConst"), TEXT(""));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapToolList_Count()
	{
		struct LeapToolList_eventCount_Parms
		{
			int32 ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapToolList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Count"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(LeapToolList_eventCount_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(ReturnValue, LeapToolList_eventCount_Parms), 0x0010000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Tool List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("count"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("count"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapToolList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Returns the number of tools in this list."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapToolList_Frontmost()
	{
		struct LeapToolList_eventFrontmost_Parms
		{
			ULeapTool* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapToolList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Frontmost"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapToolList_eventFrontmost_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapToolList_eventFrontmost_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapTool_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Tool List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("frontmost"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("frontmost"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapToolList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The member of the list that is farthest to the front within the standard Leap Motion\nframe of reference(i.e has the largest X coordinate).\n\n@return       The frontmost tool, or invalid if list is empty."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapToolList_GetPointableByIndex()
	{
		struct LeapToolList_eventGetPointableByIndex_Parms
		{
			int32 Index;
			ULeapPointable* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapToolList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetPointableByIndex"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapToolList_eventGetPointableByIndex_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapToolList_eventGetPointableByIndex_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapPointable_NoRegister());
			UProperty* NewProp_Index = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Index"), RF_Public|RF_Transient|RF_MarkAsNative) UIntProperty(CPP_PROPERTY_BASE(Index, LeapToolList_eventGetPointableByIndex_Parms), 0x0010000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Tool List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT("[]"));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("getPointableById"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("get pointable by id"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapToolList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Access a list member by its position in the list.\n\n@param        Index   position in the list.\n@return The Pointable object at the specified index."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapToolList_IsEmpty()
	{
		struct LeapToolList_eventIsEmpty_Parms
		{
			bool ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapToolList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("IsEmpty"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x54020401, 65535, sizeof(LeapToolList_eventIsEmpty_Parms));
			CPP_BOOL_PROPERTY_BITMASK_STRUCT(ReturnValue, LeapToolList_eventIsEmpty_Parms, bool);
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UBoolProperty(FObjectInitializer(), EC_CppProperty, CPP_BOOL_PROPERTY_OFFSET(ReturnValue, LeapToolList_eventIsEmpty_Parms), 0x0010000000000580, CPP_BOOL_PROPERTY_BITMASK(ReturnValue, LeapToolList_eventIsEmpty_Parms), sizeof(bool), true);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Tool List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("isEmpty"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("is empty"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapToolList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Reports whether the list is empty."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapToolList_Leftmost()
	{
		struct LeapToolList_eventLeftmost_Parms
		{
			ULeapTool* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapToolList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Leftmost"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapToolList_eventLeftmost_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapToolList_eventLeftmost_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapTool_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Tool List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("leftmost"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("leftmost"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapToolList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The member of the list that is farthest to the front within the standard Leap Motion\nframe of reference(i.e has the smallest Y coordinate).\n\n@return       The leftmost tool, or invalid if list is empty."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_ULeapToolList_Rightmost()
	{
		struct LeapToolList_eventRightmost_Parms
		{
			ULeapTool* ReturnValue;
		};
		UObject* Outer=Z_Construct_UClass_ULeapToolList();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("Rightmost"), RF_Public|RF_Transient|RF_MarkAsNative) UFunction(FObjectInitializer(), NULL, 0x04020401, 65535, sizeof(LeapToolList_eventRightmost_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(ReturnValue, LeapToolList_eventRightmost_Parms), 0x0010000000000580, Z_Construct_UClass_ULeapTool_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("Leap Tool List"));
			MetaData->SetValue(ReturnFunction, TEXT("CompactNodeTitle"), TEXT(""));
			MetaData->SetValue(ReturnFunction, TEXT("DisplayName"), TEXT("rightmost"));
			MetaData->SetValue(ReturnFunction, TEXT("Keywords"), TEXT("rightmost"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Public/LeapToolList.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("The member of the list that is farthest to the front within the standard Leap Motion\nframe of reference(i.e has the largest Y coordinate).\n\n@return       The rightmost tool, or invalid if list is empty."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ULeapToolList_NoRegister()
	{
		return ULeapToolList::StaticClass();
	}
	UClass* Z_Construct_UClass_ULeapToolList()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UObject();
			Z_Construct_UPackage__Script_LeapMotion();
			OuterClass = ULeapToolList::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20100080;

				OuterClass->LinkChild(Z_Construct_UFunction_ULeapToolList_Append());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapToolList_Count());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapToolList_Frontmost());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapToolList_GetPointableByIndex());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapToolList_IsEmpty());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapToolList_Leftmost());
				OuterClass->LinkChild(Z_Construct_UFunction_ULeapToolList_Rightmost());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_PAppendedList = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PAppendedList"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PAppendedList, ULeapToolList), 0x0040000000000000, Z_Construct_UClass_ULeapToolList_NoRegister());
				UProperty* NewProp_PPointableById = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PPointableById"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PPointableById, ULeapToolList), 0x0040000000000000, Z_Construct_UClass_ULeapTool_NoRegister());
				UProperty* NewProp_PFrontmost = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PFrontmost"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PFrontmost, ULeapToolList), 0x0040000000000000, Z_Construct_UClass_ULeapTool_NoRegister());
				UProperty* NewProp_PRightmost = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PRightmost"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PRightmost, ULeapToolList), 0x0040000000000000, Z_Construct_UClass_ULeapTool_NoRegister());
				UProperty* NewProp_PLeftmost = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("PLeftmost"), RF_Public|RF_Transient|RF_MarkAsNative) UObjectProperty(CPP_PROPERTY_BASE(PLeftmost, ULeapToolList), 0x0040000000000000, Z_Construct_UClass_ULeapTool_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapToolList_Append(), "Append"); // 942769818
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapToolList_Count(), "Count"); // 3196067973
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapToolList_Frontmost(), "Frontmost"); // 2537995298
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapToolList_GetPointableByIndex(), "GetPointableByIndex"); // 1568205708
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapToolList_IsEmpty(), "IsEmpty"); // 2485754678
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapToolList_Leftmost(), "Leftmost"); // 99502278
				OuterClass->AddFunctionToFunctionMapWithOverriddenName(Z_Construct_UFunction_ULeapToolList_Rightmost(), "Rightmost"); // 2930812411
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("LeapToolList.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("Public/LeapToolList.h"));
				MetaData->SetValue(OuterClass, TEXT("ToolTip"), TEXT("The ToolList class represents a list of Tool objects.\n\nLeap API reference: https://developer.leapmotion.com/documentation/cpp/api/Leap.ToolList.html"));
				MetaData->SetValue(NewProp_PAppendedList, TEXT("ModuleRelativePath"), TEXT("Public/LeapToolList.h"));
				MetaData->SetValue(NewProp_PPointableById, TEXT("ModuleRelativePath"), TEXT("Public/LeapToolList.h"));
				MetaData->SetValue(NewProp_PFrontmost, TEXT("ModuleRelativePath"), TEXT("Public/LeapToolList.h"));
				MetaData->SetValue(NewProp_PRightmost, TEXT("ModuleRelativePath"), TEXT("Public/LeapToolList.h"));
				MetaData->SetValue(NewProp_PLeftmost, TEXT("ModuleRelativePath"), TEXT("Public/LeapToolList.h"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ULeapToolList(Z_Construct_UClass_ULeapToolList, &ULeapToolList::StaticClass, TEXT("ULeapToolList"), false, nullptr, nullptr, nullptr);
	DEFINE_VTABLE_PTR_HELPER_CTOR(ULeapToolList);
	UPackage* Z_Construct_UPackage__Script_LeapMotion()
	{
		static UPackage* ReturnPackage = NULL;
		if (!ReturnPackage)
		{
			ReturnPackage = CastChecked<UPackage>(StaticFindObjectFast(UPackage::StaticClass(), NULL, FName(TEXT("/Script/LeapMotion")), false, false));
			ReturnPackage->SetPackageFlags(PKG_CompiledIn | 0x00000000);
			FGuid Guid;
			Guid.A = 0xBB1B9D09;
			Guid.B = 0xE6CDA38A;
			Guid.C = 0x00000000;
			Guid.D = 0x00000000;
			ReturnPackage->SetGuid(Guid);

		}
		return ReturnPackage;
	}
#endif

PRAGMA_ENABLE_DEPRECATION_WARNINGS
